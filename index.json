[
{
	"uri": "http://ccambo.github.io/FunnyLab/Blogging/change-comments-to-utterances/",
	"title": "댓글 시스템 utterances로 변경",
	"tags": ["Disqus", "utterances", "blog comments"],
	"description": "기존 Disqus 댓글 시스템의 문제점으로 Github연동형 댓글 시스템인 utternaces로 변경한 내용을 정리합니다.",
	"content": " 댓글 시스템 변경 기존에 사용하던 Disqus에 딱히 큰 문제가 있었던 것은 아니다.\n Disqus의 댓글 데이터들을 사이트들에 행동패턴등의 Big data 용도로 판매가 이뤄지고 있는 것 같다는 의심들 (차단 또는 정보공유 비활성 설정등으로 가능할 것 같다) Basic Plan인 경우는 Disqus 광고가 많은 자리를 차지한다는 것 (Ads 옵션 조정으로 광고갯수 조정 또는 유료 플랜 사용)  그러나 귀차니즘에 다른 댓글 시스템을 찾아보다가 utterances라는 github issus처럼 댓글을 관리할 수 있는 방법을 발견해서 테스트 겸 변경했다.\n Github Issue 기반이므로 (Repository 운영) 블로그 플랫폼을 변경해도 기존 Comment를 그대로 사용할 수 있다. 개발과 관련된 블로그이므로 Github 계정으로 댓글을 작성할 수 있다. 많은 블로그들이 이미 이 댓글 시스템을 사용하고 있는 것 같다.  적용하기 Utterances 사이트로 이동하면 간단하게 적용할 수 있도록 문서로 설명되어 있다. 간단히 처리를 정리하면 다음과 같다.\n github에 댓글 관리를 위한 Repository 생성 (공개형) 생성한 Repository에 utterances App 설치 utterances 사이트에 repo 정보를 \u0026ldquo;owner/repo\u0026rdquo;  형식으로 입력 \u0026ldquo;Blog Post ↔️ Issue Mapping\u0026rdquo; 항목을 자신의 블로그 플랫폼에 맞도록 선택 (이슈 제목을 블로그 경로로할지? 페이지 제목으로 할지? 임의로 지정한 값으로 할지? 등) utterances에서 생성한 이슈에 대한 라벨 설정 테마 선택  이렇게 설정하고 스크립트 태그를 블로그의 댓글 처리할 곳에 지정하면 된다.\n실제로 utterances 사이트에 정보를 입력해서 스크립트 코드를 생성해서 사용해도 되지만 그냥 스크립트만을 복사해서 내용을 원하는 (위에서 설정한 것과 같이) 데로 변경한 다음 사용해도 된다. 단, 반드시 github에 utterances.app를 먼저 설치하고 진행해야 한다. 미 설치시 댓글시스템은 동작을 하지만 포스트와 연결되지는 않는다. \n 지금 보고 있는 이 글의 댓글은 utterances를 스트립트만 변경해서 적용한 것이다.\n참고자료  Utterance  "
},
{
	"uri": "http://ccambo.github.io/Dev/Vue/intro_key_of_vue/",
	"title": "Vue 키 포인트 소개",
	"tags": ["Vue"],
	"description": "프로젝트에 Vue를 도입한 결정적인 이유",
	"content": " 프로젝트에서 사용할 Front-End Framework을 고심하던 중에 Gregg이 Vue.js를 소개하는 공식 자료를 보고 Vue를 선택했다. 아래의 내용은 참고자료에 언급한 원문을 번역하면서 나름대로 정리한 것으로 왜 Vue가 43%의 개발자들이 vue.js를 배우려고 하는지를 알 수 있다.\n현재 TOP 3 (Angular, React, Vue)의 자바스크립트들에 대한 비교는 vue.js 공식문서를 참고하면 된다.\n 점진적인 프레임워크 Vue는 진입장벽이 낮고, 유연하고, 성능이 우수하고, 유지보수와 테스트가 편한 자바스크립트 프레임워크로 점진적인 프레임워크를 지향  하고 있다. 점진적인 프레임워크라는 것은 웹 어플리케이션 전체를 한꺼번에 하나의 프레임워크 구조로 구조화하지 않아도 일정 부분만 적용 가능  해서 사용자에게 더 좋은 사용자 경험을 제공할 수 있다는 것을 의미한다. 물론 전체를 처음부터 Vue로 구현할 수도 있다. Vue가 큰 규모의 어플리케이션을 개발할 수 있도록 핵심 라이브러리와 주변 생태계를 제공하고 있다.\n[출처:Vuejs - 점진적인 프레임워크]  재 사용 가능한 컴포넌트 (단일 파일 컴포넌트) 다른 프레임워크들처럼 재 사용이 가능한 컴포넌트로 웹 페이지를 구성할 수 있으며, 각 컴포넌트는 페이지 영역을 표시하는데 필요한 HTML, CSS, Script 를 가지는 단일 파일 컴포넌트 구조를 제공한다.\n[출처:Vuejs - 컴포넌트로 페이지 구성]  프로젝트로 알아보기 아주 간략하고 특징적인 Vue의 주요 컨셉을 알아볼 수 있다.\n대 부분의 자바스크립트와 같이 페이지에 데이터를 표시하는 것부터 시작한다.\n[출처:Vuejs - 페이지에 데이터 표시]  위의 그림에 표시된 것과 같이 \u0026ldquo;X\u0026rdquo;의 위치에 스크립트에서 설정한 \u0026ldquo;Boots\u0026rdquo;를 표시하고 싶으면 아래와 같이 구현하면 된다.\n[출처:Vuejs - Vue로 페이지에 데이터 표시]  위의 내용을 좀 더 자세히 확인하면 다음과 같다.\n 정보를 표시할는 것은 Vue의 데이터를 바인딩할 때 사용하는 \u0026ldquo;{{ ... }}\u0026rdquo; 를 사용한다. 위의 예는 Vue 에서 관리하는 데이터 중에서 \u0026ldquo;product\u0026rdquo;라는 정보를 출력한다는 의미다. 물론 아직 데이터는 없다. \u0026lt;script\u0026gt;...\u0026lt;/script\u0026gt; 로 Vue 라이브러리를 포함시키고 구동 가능한 상태로 만든다. const app = new Vue({ ... }) 코드로 Vue 인스턴스를 생성한다. Vue 인스턴스를 생성할 떄 동작에 필요한 옵션을 지정한다.  el : Vue 인스턴스가 DOM과 연계될 수 있도록 대상 엘리먼트를 지정한다. data : Vue 동작에 필요한 데이터를 JSON 형식으로 지정한다.   위의 코드를 실행하면 아래와 같이 결과를 확인할 수 있다.\n[출처:Vuejs - 정적 데이터 표시]  위의 결과까지는 일반적인 수준이지만 정적이 아닌 동적으로 데이터가 변경될 때 Vue의 마법을 경험할 수 있다. 아래와 같이 개발자 도구의 콘솔에서 데이터를 변경하면 어떻게 데이터가 연동되는지를 확인할 수 있다.\n[출처:Vuejs - 동적 데이터 표시]  위의 결과에서 알 수 있듯이 Vue는 데이터가 변경되면 Vue에서 알아서 변경된 내용을 처리하는 방식을 제공한다. 이 동작은 문자열뿐만 아니라 모든 유형의 데이터에 모두 적용된다. 이를 확인해 보기 위해서 위의 샘플 코드를 배열을 처리할 수 있도록 \u0026quot;ul\u0026quot; 태그와 \u0026quot;li\u0026quot; 태그 구조로 변경한다. 이때 템플릿처럼 구성하는 것이기 때문에 v-for라는 특별한 속성을 지정 (foreach 문장구조와 비슷)  해야 한다. 그리고 Vue 인스턴스 생성할 떄의 data 부분을 배열구조인 products로 변경한다.\n[출처:Vuejs - 동적 데이터 표시 (v-for 지시자 사용)]  변경된 코드를 브라우저에서 실행해 보면 아래와 같은 결과를 확인할 수 있다.\n[출처:Vuejs - 동적 데이터 표시 결과]  좀 더 확장을 해서 서버를 호출해서 데이터를 받아온 결과를 기준으로 화면에 동적으로 출력하는 것으로 가정하면 아래와 같이 코드를 구성하면 된다.\n[출처:Vuejs - 동적 데이터 표시 (API 호출))]  위의 코드를 살펴보면 다음과 같은 변화가 있다.\n data를 products라는 빈 배열로 초기화만 처리한다. created 라는 vue 인스턴스의 생성시점에 호출되는 이벤트를 사용해서 API 호출 코드를 작성한다.  fetch 메서드를 통해서 API를 호출한다. then 메서드를 이용해서 API 호출 결과를 Vue에서 관리하는 데이터로 변환해서 설정한다.   위의 코드에서 호출된 API의 결과는 JSON형식으로 실행된 화면은 아래와 같이 표시된다.\n[출처:Vuejs - 동적 데이터 표시 (API 호출 결과))]  API에서 반환된 JSON을 그대로 출력한 것이기 떄문에 이를 좀 더 사용자에게 친숙한 형식으로 처리하기 위해서 아래와 같이 View 처리를 변경한다.\n[출처:Vuejs - v-for 지시자 표현식)]  수행된 결과는 반환된 결과에서 product.quantity와 product.name 만을 출력하는 것으로 변경했기 때문에 아래와 같이 나타난다.\n[출처:Vuejs - v-for 지시자 표현식 결과)]  각 데이터 항목중에서 갯수가 0인게 있으면 사용자가 좀 더 잘 인식할 수 있도록 \u0026ldquo;\u0026lt;span\u0026gt;\u0026rdquo; 태그를 사용해서 item.quantity === 0 일 때만 \u0026ldquo;OUT OF STOCK\u0026rdquo; 텍스트가 보이도록 아래와 같이 변경한다.\n[출처:Vuejs - v-for 지시자 표현식)]  위의 표현식에서는 v-if 지시자를 이용해서 조건식을 구성해서 재고 여부를 좀 더 확실하게 구분할 수 있도록 변경했다.\n[출처:Vuejs - v-if 지시자 표현식)]  이제 모든 상품의 총 재고량을 목록 아래쪽에 표시하려면 totalProducts라는 computed 속성을 활용하면 된다. 만일 자바스크립트의 reduce() API가 익숙하지 않다면 그냥 재고 총합을 구하는 동작이라고 이해하면 된다.\n[출처:Vuejs - computed 속성)]  실행을 해 보면 아래와 같이 모든 상품의 총 재고량이 계산되어 표시된다.\n[출처:Vuejs - computed 속성 결과)]  Vue 개발자 도구(Vue.js Chrome Extension)의 장점 중에 하나는 페이지상에 표시된 데이터를 살펴볼 수 있다는 점이다.\n[출처:Vuejs - Vue Dev Tools)]  앞에서 보았던 데이터의 변화가 View에 동적으로 표현되는 부분을 다시 한번 확인할 겸해서 개발자 도구의 콘솔에서 2개의 product를 제거해 보면 아래와 같이 리스트뿐만 아니라 총 재고량도 변경되는 것을 확인할 수 있다.\n[출처:Vuejs - Vue Dev Tools에서 데이터 변경 결과]  이번에는 버튼을 사용해서 페이지에 이벤트를 추가하고 버튼을 눌렀을 때 각 상품의 재고량을 1개씩 늘리는 것으로 변경해 보도록 한다.\n[출처:Vuejs - v-on click 이벤트)]  실행해 보면 Add 버튼을 눌렀을 때 각 상품의 재고와 총 재고량의 숫자를 증가시키는 것과 Jacket 상품에서는 OUT OF STOCK 글씨도 사라지는 것을 확인할 수 있다.\n[출처:Vuejs - v-on click 이벤트 결과)]  좀 더 확장해서 재고량을 직접 입력할 수 있도록 input 박스를 추가하고 v-model 지시자를 연결하고 입력되는 값은 항상 숫자인 것으로 지정하도록 변경한다.\n[출처:Vuejs - v-model 지시자)]  위의 input 박스에는 양방향 바인딩을 위한 v-model 지시자를 이용해서 숫자인 데이터를 Vue에서 관리하고 있는 데이터 항목에 연동하는 설정을 한 것이다.\n이제 버튼을 통한 것뿐만 아니라 사용자가 직접 숫자를 입력해서 재고를 변경할 수도 있다. 물론 0으로 숫자를 설정하는 OUT OF STOCK이 표시되는 것도, Add 버튼 처리도 모두 잘 동작하는 것을 확인할 수 있다.\n[출처:Vuejs - v-model 지시자 결과)]  지금까지 설명하고 실행해서 검증했던 소스는 JSFIDDLE에서 확인할 수 있다.\n추가적인 Vue 특징  규모가 있는 어플리케이션을 구축한다면 여러 개의 컴포넌트를 조합해야 한다.  [출처:Vuejs - Single file components)] \n Vue는 CLI (Command Line Interface) 명령어 도구를 이용해서 쉽게 프로젝트를 생성할 수 있다. 아래의 명령으로 프로젝트를 시작하면 된다. [출처:Vuejs - Vue-cli)] \n 컴포넌트 별로 .vue 파일을 생성해서 관리할 수 있고, 각 .vue 파일에는 HTML, Javascript, CSS \u0026amp; SCSS 가 들어간다. (Single file component) [출처:Vuejs - Vue Component System)] \n  결론 지금까지 Vue가 할 수 있는 기능들 중에서 아주 기초적인 일부만 확인해 봤다. Vue에는 프론트엔드 화면을 개발하고, 구성하고, 빌드하기 위한 더 많은 기능들이 존재한다. 만일 Vue를 배우고 싶다면 아래의 2가지 자료를 추천한다.\n VueMastery의 Vue Guide \u0026amp; CheatSheet : 무료 소개 과정과 계정을 만들면 CheatSheet를 받을 수 있다. Vue.js 공식 문서  참고자료  Why 43% of Front-End Developers want to learn Vue.js  "
},
{
	"uri": "http://ccambo.github.io/Dev/Web/npm_vs_yarn/",
	"title": "NPM vs YARN",
	"tags": ["npm", "yarn"],
	"description": "npm과 yarn에 대한 비교",
	"content": " node + npm이 기본이었는데, 몇 가지 npm의 문제점을 해결하기 위해 yarn이 발표되었다.\n기존 NPM은 배포가 쉽고, 종속성을 쉽게 해결할 수 있지만 패키지가 중복으로 설치될 수 있고, 파일이 많은 경우에 문제가 될 수 있다. 페이스북에서는 이런 문제점들을 해결하기 위해서 yarn을 발표했다.\n npm3 보다 패키지 설치 속도가 빠르다. json 포맷을 사용하지 않는다. offline 모드가 가능하다.  YARN 설치  설치페이지를 통해서 직접 설치가 가능하다. 맥북이라면 brew를 이용해서 설치가 가능하다. npm을 통해서도 설치가 가능하다.  터미널에서의 설치는 다음의 명령으로 처리하면 된다.\n Yarn 설치 명령  $ npm install -g yarn # npm 사용 $ brew install yarn # 맥북   명령 비교 NPM과 YARN 기본 명령들 비교   npm 명령 yarn 명령 설명     npm init yarn init 프로젝트 초기화   npm install yarn or yarn install package.json 의 패키지 설치   npm install \u0026ndash;save [package name] yarn add [package name ] 패키지를 프로젝트 의존성 수준으로 추가 (dependencies)   npm install \u0026ndash;save-dev [package name] yarn add -D[or \u0026ndash;dev] [package name] 패키지를 프로젝트 개발 의존성 수준으로 추가 (Devdependencies)   npm install \u0026ndash;global [package name] yarn global add [package name] 패키지를 전역 수준으로 추가   npm update \u0026ndash;save yarn upgrade 프로젝트의 패키지 업데이트   npm run [script name] yarn [script name] package.json의 scripts에 지정된 명령 실행   npm uninstall \u0026ndash;save [package name] yarn remove [package name] 패키지 삭제   npm cache clean yarn cache clean 캐시 삭제    참고자료  yarn 특징과 성능  "
},
{
	"uri": "http://ccambo.github.io/Cloud/Concepts/edge-computing/",
	"title": "Edge Computing",
	"tags": ["Edge Computing"],
	"description": "Edge Computing에 대한 내용을 정리합니다.",
	"content": " 엣지 컴퓨팅이란? 클라우드 컴퓨팅이란 인터넷을 통해 서버, 저장소, 소프트웨어, 분석 등의 컴퓨팅 서비스를 제공하는 것을 말한다. 이미 많은 기업들이 클라우드 환경으로 전환했으며, 이 과정에서 여러 가지 문제점들이 발생하게 된다.\n 사용자의 폭발적인 증가로 인해 서버 및 데이터 센터에서 처리할 수 있는 데이터 양을 넘어서기 시작하면서 데이터 처리 속도 문제 데이터의 송/수신 과정의 지연 현상 발생 (Latency) 통신 과정 상의 보안 문제  이런 문제점들을 해결하기 위해서 \u0026ldquo;사용자의 단말 또는 가까운 위치에서 컴퓨팅을 수행\u0026rdquo;  하는 방식의 엣지 컴퓨팅 개념이 탄생했다.\n데이터를 데이터 센터로 전송하고 데이터를 처리하는 방식의 클라우드 컴퓨팅과는 달리 엣지 검퓨팅은 스마트폰과 같은 단말(엣지) 기기 또는 가까운 위치에서 데이터를 처리하는 분산 개방형 아키텍처를 말하며 이를 기반으로 모바일 컴퓨팅 및 IoT (Internet of Things) 기술을 활용할 수 있다.\n[출처 : 삼성 뉴스룸 - 엣지컴퓨팅]  [출처 : 위키백과]  엣지 컴퓨팅이 필요한 이유 클라우드 컴퓨팅에서는 발생한 데이터를 클라우드로 전송하고 데이터를 가공하고 결과를 받는 형식이지만 엣지 컴퓨팅에서는 사용자 또는 데이터 소스의 물리적인 위치나 그 위치와 가까운 곳에서 컴퓨팅이 수행되기 때문에 사용자는 더욱 빠르고 안정적인 서비스를 제공받을 수 있으며, 기업은 유연한 하이브리드 클라우드 컴퓨팅의 이점을 얻을 수 있다. 따라서 엣지 컴퓨팅을 활용하면 기업이 다수의 위치에서 공통의 리소스 풀을 사용해서 데이터 연산 및 처리를 분산시킬 수 있는 방법으로 구축이 가능하게 된다.\n 데이터 부하 감소 클라우드 컴퓨팅에서는 모든 발생 데이터가 취합되고 처리되기 때문에 데이터 양에 따른 부하가 생기지만, 엣지 컴퓨팅은 해당 단말 또는 해당 지역에서 발생하는 데이터로 한정되어 처리하므로 부하를 줄일 수 있다. 보안 클라우드 컴퓨팅은 클라우드로 데이터를 전송/전달 단계부터 보안에 대한 요구가 존재하게 되지만, 엣지 컴퓨팅은 데이터 수집과 처리를 해당 단말 또는 가까운 지역에서 처리하므로 상대적으로 보안이 좋다 장애 대응 클라우드 컴퓨팅은 클라우드 장애가 발생하면 치명적이지만, 엣지 컴퓨팅은 자체적으로 컴퓨팅을 수행하기 때문에 효과적으로 대응이 가능하다.  엣지 컴퓨팅 사례  가상/증강 현실 : 종종 대역폭 부족과 긴 지연 시간의 문제가 발생한다. 이로 인해서 몰입이 방해되는 경우가 많기 때문에 엣지 컴퓨팅을 활용해서 렌더링 파이프라인의 컴퓨터 집약적인 부분을 클라우드로 이전하여 이런 문제를 해결할 수 있다. 스마트 카/스마트팩토리 : 길 안내를 하고 있는 상황에서의 데이터 처리 지연은 악몽이 된다. 따라서 자동차 또는 IoT 기기가 엣지 컴퓨팅을 활용해서 실시간 데이터를 처리하고 결정을 내릴 수 있도록 할 수 있다. 보안 및 GDPR(규제 정책) : 엣지 컴퓨팅을 활용해서 컴퓨팅 기능 (데이터 수집과 처리 등)을 로컬 네트워크에서 수행함으로써 민감한 데이터의 유출이 완화되므로 기업들이 정보(영업 비밀 등)의 확산을 효과적으로 통제하고 규제 정책(GDPR 등)을 준수 할 수 있다. 장애 대응 : 엣지 컴퓨팅을 활용해서 클라우드 컴퓨팅 대비 복구 능력과 비용 절감 효과를 누릴 수 있으며, 주요 기능이 로컬 네트워크에서 수행되기 때문에 클라우드가 어떤 이유로 장애가 발생해도 지역 사이트는 독립적으로 계속 운영이 가능하고, 클라우드와 지역 사이트 간의 데이터를 교류하기 위해 소비되는 대역폭 비용도 크게 절감이 가능하다.  엣지 컴퓨팅의 이점  클라우드 컴퓨팅은 몇몇의 대규모 데이터 센터로 서비스를 중앙 집중화하는데 초점에 맞춰져있고 이를 통해서 제어 능력과 기업 보안을 유지하면서도 리소스의 확장성을 높이고 보다 효율적인 공유가 가능하다. 반면에 엣지 컴퓨팅은 주로 네트워크 요구사항 또는 기타 제약으로 클라우드 컴퓨팅의 중앙집중식 접근방식으로 적절하게 해결할 수 없는 활용 사례를 처리한다. 여러 소규모의 컴퓨팅 사이트에 중점을 두고 네트워크 비용을 절감하고 대역폭 제한을 피하며, 전송 지연과 서비스 장애를 줄이고, 민감한 데이터의 이동을 더욱 효과적으로 제어할 수 있다. 어플리케이션의 로드 시간을 단축하고 사용자 가까이에서 배포되는 온라인 서비스를 통해서 동적 및 정적 캐시 기능을 모두 지원할 수 있으므로 최종 사용자에게 더욱 빠르고 일관성있는 사용자 환경을 제공할 수 있다. 기업과 서비스 제공업체는 실시간 모니터링이 가능하며, 지연 시간이 짧고 가용성이 높은 어플리케이션 구현이 가능하다.  엣지 컴퓨팅의 과제 가장 큰 문제점은 고도로 분산된 환경에서 규모를 확장하는 상황에서 발생한다.\n 클라우드 컴퓨팅의 중앙집중적 시스템에서는 스케일 아웃하는 것이 상대적으로 쉽지만, 많은 소규모 사이트가 연계되는 엣지 컴퓨팅에서는 훨씬 복잡하며, 물리적인 위치에 따른 오버헤드가 증가하여 소규모 기업에서 관리하기에는 부담이 될 수 있다. 소규모 사이트는 전문 기술자가 없거나 제한적인 원격지일 가능성이 높기 때문에 장애가 발생하는 경우 비기술 현장 인력이 해결하고 다른 지역의 전문 인력이 중앙에서 관리할 수 있도록 인프라를 구축해야 한다. 각 사이트 관리 작업은 모든 사이트에서 적용 가능하도록 간단해야 하며, 문제 해결을 지원해야 하고, 각 사이트에서 소프트웨어 설정이 다른 방식으로 구현되는 것을 방지할 수 있어야 한다. 데이터를 지리적으로 제한하여 정보의 흐름을 효과적으로 운영할 수는 있지만, 각 사이트에 대한 물리적인 보안은 취약할 수 밖에는 없기 때문에 악의적인 공격이나 우발적인 손상으로 인한 문제 발생 위험은 오히려 더 높을 수 있다.  참고자료  엣지 컴퓨팅? 엣지 컴퓨팅  "
},
{
	"uri": "http://ccambo.github.io/Dev/Vue/vue/",
	"title": "Vue 기본 개념",
	"tags": ["Vue", "Vue.js"],
	"description": "Vue.js에 대한 간략한 기본 개념 소개",
	"content": " 이 문서는 vue에 대한 빠르고 개략적인 이해를 위해서 간략한 개념만을 정리하고 있다. 따라서 실제 프로젝트에 적용하기 위해서는 참고문서에 지정된 공식문서와 다른 분들이 정리해 놓은 자료들을 참고하도록 한다. 현재 진행 중인 프로젝트에 무사히(?) 적용을 끝내고 나면 그 과정을 기준으로 새로운 정리 문서들을 추가할 예정이다.\n Vue? Vue 가 무엇인가에 대한 것은 Vue 키 포인트 소개 (Gregg 소개 자료)를 참고하면 쉽게 이해할 수 있다.\n 현재 Top 3(Angular, React, Vue)에 해당하는 Javascript Framework으로 MVVM(Model-View-ViewModel) 패턴 기반의 UI 라이브러리\n 데이터 바인딩과 화면 단위를 컴포넌트 형태로 제공하며, 관련된 API를 지원한다. 양방향 데이터 바인딩 지원 (Component \u0026lt;-\u0026gt; Model) 컴포넌트간의 통신은 React와 같이 단방향 데이터 흐름 (Parent -\u0026gt; Child) 사용 Angular, React 등과 비교해서 상대적으로 가볍고 빠름 문법이 단순하고 간결해서 진입장벽이 낮고 쉽게 접근 가능 Virtual DOM 지원 Single file copmpoent 지원 View에 최적화되어 있어 jQuery등을 이용한 DOM 조작이 필요없다. 많은 모듈들의 지원과 한글화된 정보들이 많이 존재한다.  Vuex : 중앙집중식 상태관리 저장소 vue-router : SPA를 위한 라우터 vue-resource : HTTP, Ajax, \u0026hellip; vue-devtools : Vue에 최적화된 개발자 모드   MVVM 패턴이란? 서버와 클라이언트의 UI 코드와 데이터를 분리하기 위한 기본적인 구조인 MVC (Model-View-Controller) 패턴에서 파생된 것으로 쉽게 생각하면 서버와 연계되는 데이터(Model)와 UI 코드 및 UI 동작 (View) 간의 분리와 데이터 연계를 위한 중간 매개체로의 역할 (ViewModel)을 담당하는 패턴을 의미한다.\n[ MVVM 패턴 ]  Vue Instance 모든 Vue 어플리케이션들은 Vue 함수를 이용해서 인스턴스를 만드는 것부터 시작된다.\n아래의 예제는 아주 간단한 \u0026ldquo;Hello Vue\u0026rdquo;를 출력하는 기본 샘플이다.\n1\u0026lt;!DOCTYPE html\u0026gt; 2\u0026lt;html\u0026gt; 3 \u0026lt;head\u0026gt; 4 \u0026lt;title\u0026gt;Vue First Sample\u0026lt;/title\u0026gt; 5 \u0026lt;/head\u0026gt; 6 \u0026lt;body\u0026gt; 7 \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; 8 {{ message }} 9 \u0026lt;/div\u0026gt; 10 11 \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/vue/dist/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 12 \u0026lt;script\u0026gt; 13 new Vue({ 14 el: \u0026#39;#app\u0026#39;, 15 data: { 16 message: \u0026#39;Hello Vue.js!\u0026#39; 17 } 18 }) 19 \u0026lt;/script\u0026gt; 20 \u0026lt;/body\u0026gt; 21\u0026lt;/html\u0026gt;  11번 라인에서 Vue.js 스크립트 지정 13-18번 라인에서 Vue Instance 생성 14번 el은 Vue 인스턴스가 마운트될 DOM 의 엘리먼트를 지정 15번 data는 Model 데이터 지정  \u0026lt;script\u0026gt; ... new Vue({ // option properties }) ... \u0026lt;/script\u0026gt; 옵션으로 지정할 수 있는 속성들은 다음과 같다.\n data : 뷰의 반응성(Reactivity)이 반영될 데이터 속성 template : 화면에 표시할 요소 (HTML, CSS 등) el : vue 인스턴스가 연계될 HTML 엘리먼트 methods : 화면의 동작과 이벤트를 처리하기 위한 메서드 events (life cycle hooks) : Vue 라이프사이클에 맞는 이벤트 훅 watch: data에 정의한 속성이 변경 (양방향 Binding)되었을 떄 추가 동작을 수행할 수 있도록 정의하는 속성 \u0026hellip;  옵션으로 지정 가능한 전체 목록은 Vue 공식사이트의 API문서를 참고하면 된다.\n Vue 라이프 사이클 Vue는 아래와 같은 라이프 사이클을 가진다.\n[출처:Vue공식문서 - 라이프사이클 다이어그램]  위의 그림을 단순한 진행 스텝 단위로 정리하면 아래와 같고, 우리가 사용하게될 부분은 굵은 글씨로 표현된 이벤트 훅을 받아서 필요한 처리를 수행하면 된다.\n Vue 인스턴스 생성 events and lifecycle 초기화  beforeCreate 이벤트 훅 발생  injections and reactivity 초기화  created 이벤트 훅 발생  Vue 인스턴스 연결 (el option 지정에 따라 vm.$mount(el) 호출) 템플릿 구성 (템플릿 미지정시는 el의 outerHTML을 템플릿으로 처리)  beforeMount 이벤트 훅 발생  vm.$el 변수 생성 및 el 엘리먼트를 Vue 인스턴스로 대체  mounted 이벤트 훅 발생  데이터 변경 발생시 Virtual DOM에 적용  데이터 변경 전에 beforeUpdate 이벤트 훅 발생 데이터 변경 후에 updated 이벤트 훅 발생  vm.$destroy() 메서드 호출되면 종료 진행  beforeDestroy 이벤트 훅 발생 watchers, child components, event listeners 들 종료 destroyed 이벤트 훅 발생   Vue Components 기본 HTML 엘리먼트를 확장해서 재 사용 가능한 코드로 캡슐화한 것으로 HTML + CSS + SCRIPT 의 구성으로 특정한 기능성을 제공하기 위한 것이다.\n[출처:Cracking Vue.js - 컴포넌트 구성]  따라서 컴포넌트를 기반으로 화면을 개발하면 코드의 재 사용성이 올라가고 일관성 유지를 하면서 빠르게 개발이 가능하다.\nVue는 사용자 지정 태그 이름에 대한 W3C 규칙을 따르지 않고 아래의 규칙을 사용한다. - 모두 소문자로 구성한다.  - \u0026rsquo;-\u0026rsquo; 을 포함해야 한다.\n 전역 컴포넌트 Vue 인스턴스에 직접 컴포넌트를 등록한다. Vue.component(tagName, options)\n1... 2\u0026lt;div id=\u0026#34;example\u0026#34;\u0026gt; 3 \u0026lt;my-component\u0026gt;\u0026lt;/my-component\u0026gt; 4\u0026lt;/div\u0026gt; 5... 6\u0026lt;script\u0026gt; 7... 8// 전역 컴포넌트 등록 9Vue.component(\u0026#39;my-compoent\u0026#39;, { 10 // options 11 template: \u0026#39;\u0026lt;div\u0026gt;사용자 정의 컴포넌트!!\u0026lt;/div\u0026gt;\u0026#39; 12}) 13... 14// 인스턴스 생성 15new Vue({ 16 // option properties 17 el: \u0026#39;#example\u0026#39; 18}) 19 20... 21\u0026lt;/script\u0026gt; 실행된 결과는 다음과 같다.\n1// 렌더링 결과 2\u0026lt;div id=\u0026#34;example\u0026#34;\u0026gt; 3 \u0026lt;div\u0026gt;사용자 정의 컴포넌트!!\u0026lt;/div\u0026gt; 4\u0026lt;/div\u0026gt; 지역 컴포넌트 모든 컴포넌트를 전역으로 등록할 필요는 없다. 컴포넌트를 components 라는 인스턴스 옵션으로 등록해서 다른 인스턴스 또는 컴포넌트의 범위 내에서 사용하도록 할 수도 있다.\n1var Child = { 2 template: \u0026#39;\u0026lt;div\u0026gt;사용자 정의 컴포넌트!!\u0026lt;/div\u0026gt;\u0026#39; 3} 4 5new Vue({ 6 // ... 7 components: { 8 // \u0026lt;my-component\u0026gt; 는 상위 템플릿에서만 사용할 수 있습니다. 9 \u0026#39;my-component\u0026#39;: Child 10 } 11}) 컴포넌트 사용시 주의할 점  DOM 템플릿 구문 오류 Vue는 템플릿 컨텐츠를 처리할 때 HTML이 동작하는 고유의 몇가지 제한 사항이 존재하며 브라우저가 구문 분석과 정규화한 후에 동작하기 때문에 \u0026lt;ul\u0026gt;, \u0026lt;ol\u0026gt;, \u0026lt;table\u0026gt;, \u0026lt;select\u0026gt;와 \u0026lt;option\u0026gt; 등과 같이 제한이 존재하는 경우는 오류가 발생하게 된다. 따라서 이런 문제를 해결하기 위해서는 is 라는 특수한 속성을 이용해야 한다. 1 \u0026lt;table\u0026gt; 2 \u0026lt;my-row\u0026gt;...\u0026lt;/my-row\u0026gt; \u0026lt;!-- \u0026lt;tr\u0026gt; 태그가 아닌 사용자 정의 컴포넌트가 존재하므로 오류 발생 --\u0026gt; 3 \u0026lt;/table\u0026gt; 4 5 \u0026lt;!-- 위의 문제를 해결하기 위해서는 아래와 같이 특수 속성을 사용해야 한다. --\u0026gt; 6 \u0026lt;table\u0026gt; 7 \u0026lt;tr is=\u0026#34;my-row\u0026#34;\u0026gt;...\u0026lt;/my-row\u0026gt; \u0026lt;!-- \u0026lt;tr\u0026gt; 에 \u0026#34;is\u0026#34; 속성으로 컴포넌트 연결 --\u0026gt; 8 \u0026lt;/table\u0026gt; 9  물론 순수하게 DOM 파싱을 거치지 않는 경우는 예외적으로 사용할 수 있다.  \u0026lt;script type=\u0026quot;text/x-template\u0026quot;\u0026gt; 에서 사용하는 경우 Javascript 인라인 템플릿 문자열 .vue 컴포넌트  data option은 반드시 함수여야 한다 Vue 생성자에 사용할 수 있는 대부분의 옵션들은 컴포넌트에서도 사용할 수 있지만 data의 경우는 반드시 함수여야 한다. 1 Vue.component(\u0026#39;my-component\u0026#39;, { 2 template: \u0026#39;\u0026lt;span\u0026gt;{{ message }}\u0026lt;/span\u0026gt;\u0026#39;, 3 data: { // 함수가 아니므로 경고 표시됨. 4 message: \u0026#39;hello\u0026#39; 5 } 6 }) 7  아래와 같이 함수로 처리해서 사용하면 된다. 1 ... 2 \u0026lt;div id=\u0026#34;example-2\u0026#34;\u0026gt; 3 \u0026lt;simple-counter\u0026gt;\u0026lt;/simple-counter\u0026gt; 4 \u0026lt;simple-counter\u0026gt;\u0026lt;/simple-counter\u0026gt; 5 \u0026lt;simple-counter\u0026gt;\u0026lt;/simple-counter\u0026gt; 6 \u0026lt;/div\u0026gt; 7 ... 8 \u0026lt;script\u0026gt; 9 var data = { counter: 0 } 10 11 Vue.component(\u0026#39;simple-counter\u0026#39;, { 12 template: \u0026#39;\u0026lt;button v-on:click=\u0026#34;counter += 1\u0026#34;\u0026gt;{{ counter }}\u0026lt;/button\u0026gt;\u0026#39;, 13 // 데이터는 기술적으로 함수이므로 Vue는 따지지 않지만 14 // 각 컴포넌트 인스턴스에 대해 같은 객체 참조를 반환합니다. 15 data: function () { 16 return data // 객체 반환 17 } 18 }) 19 20 new Vue({ 21 el: \u0026#39;#example-2\u0026#39; 22 }) 23 \u0026lt;/script\u0026gt; 24  위의 예제는 정상적으로 잘 동작을 하지만 잘 보면 data란 객체를 생성하고 이를 반환하는 함수로 data 옵션을 구성했기 때문에 모든 컴포넌트가 동일한 객체를 바라보기 때문에 하나의 컴포넌트에서 값을 바꾸면 모든 컴포넌트가 변경되는 문제가 발생한다. 이를 해결하기 위해서는 아래와 같이 코드를 작성해야 한다. 1 ... 2 \u0026lt;div id=\u0026#34;example-2\u0026#34;\u0026gt; 3 \u0026lt;simple-counter\u0026gt;\u0026lt;/simple-counter\u0026gt; 4 \u0026lt;simple-counter\u0026gt;\u0026lt;/simple-counter\u0026gt; 5 \u0026lt;simple-counter\u0026gt;\u0026lt;/simple-counter\u0026gt; 6 \u0026lt;/div\u0026gt; 7 ... 8 \u0026lt;script\u0026gt; 9 Vue.component(\u0026#39;simple-counter\u0026#39;, { 10 template: \u0026#39;\u0026lt;button v-on:click=\u0026#34;counter += 1\u0026#34;\u0026gt;{{ counter }}\u0026lt;/button\u0026gt;\u0026#39;, 11 // 데이터는 기술적으로 함수이므로 Vue는 따지지 않지만 12 // 각 컴포넌트 인스턴스에 대해 같은 객체 참조를 반환합니다. 13 data: function () { 14 return 0 // 객체마다 0 반환 (고유 값 배정됨) 15 } 16 }) 17 18 new Vue({ 19 el: \u0026#39;#example-2\u0026#39; 20 }) 21 \u0026lt;/script\u0026gt; 22   컴포넌트간의 관계 컴포넌트는 주로 부모-자식 관계로 구성된다. 부모 컴포넌트의 템플릿에서 자식 컴포넌트를 지정해서 사용하는 방식이기 때문에 서로 간의 정보 소통이 필요하다.\n[출처:Vue공식문서 - 컴포넌트 관계]  위의 그림과 같이 부모는 자식에서 속성 값을 전달하고, 자식은 부모에서 이벤트로 전달하는 방식을 취하기 때문에 각 컴포넌트의 코드가 격리된 상태로 운영되고 재 사용할 수 있다.\n 부모에서 자식으로 데이터 전달\n props 데이터 전달  prop는 부모 컴포넌트의 정보를 전달하기 위한 사용지 지정 특성이며, 자식 컴포넌트는 props 옵션을 사용해서 받을 수 있다. 1 \u0026lt;script\u0026gt; 2 Vue.component(\u0026#39;child\u0026#39;, { 3 // props 정의 4 props: [\u0026#39;message\u0026#39;], 5 // 데이터와 마찬가지로 prop은 템플릿 내부에서 사용할 수 있으며 6 // vm의 this.message로 사용할 수 있습니다. 7 template: \u0026#39;\u0026lt;span\u0026gt;{{ message }}\u0026lt;/span\u0026gt;\u0026#39; 8 }) 9 \u0026lt;/script\u0026gt; 10 11 \u0026lt;child message=\u0026#34;안녕하세요!\u0026#34;\u0026gt;\u0026lt;/child\u0026gt; \u0026lt;!-- 부모 컴포넌트에서 message라는 props로 지정된 속성을 통해서 값 전달 --\u0026gt; 12  props 설정할 때의 camelCase, kebab-case 사용 스크립트에서는 카멜케이스를 사용하지만 HTML에서는 대소문자를 구별하지 않기 때문에 템플릿에서 사용할 때는 케밥케이스를 사용해야 한다. 1 \u0026lt;child my-message=\u0026#34;안녕하세요!\u0026#34;\u0026gt;\u0026lt;/child\u0026gt; \u0026lt;!-- HTML는 kebab-case를 사용해서 `my-message`로 표현 --\u0026gt; 2 3 \u0026lt;script\u0026gt; 4 Vue.component(\u0026#39;child\u0026#39;, { 5 props: [\u0026#39;myMessage\u0026#39;], // JavaScript는 camelCase로 `myMessage`로 표현 6 template: \u0026#39;\u0026lt;span\u0026gt;{{ myMessage }}\u0026lt;/span\u0026gt;\u0026#39; 7 }) 8 \u0026lt;/script\u0026gt; 9  문자열 템플릿을 이용하는 경우는 이 제한이 적용되지 않는다.   자식 컴포넌트에서 부모 컴포넌트로 데이터 전달\n 템플릿에 v-on:eventName을 지정해서 부모 자식간의 이벤트 전달 및 수신 자식 컴포넌트에서 $emit(eventName)을 호출해서 부모로 전달할 이벤트 작동 1 \u0026lt;div id=\u0026#34;counter-event-example\u0026#34;\u0026gt; 2 \u0026lt;p\u0026gt;{{ total }}\u0026lt;/p\u0026gt; \u0026lt;!-- 자식 컴포넌트에서 잔달된 값을 누적해서 출력 --\u0026gt; 3 \u0026lt;button-counter v-on:increment=\u0026#34;incrementTotal\u0026#34;\u0026gt;\u0026lt;/button-counter\u0026gt; \u0026lt;!-- v-on:increment 설정으로 자식에서 전달된 이벤트 수신하여 incrementTotal 메서드 호출 (부모 컴포넌트 입장의 이벤트 수신) --\u0026gt; 4 \u0026lt;button-counter v-on:increment=\u0026#34;incrementTotal\u0026#34;\u0026gt;\u0026lt;/button-counter\u0026gt; \u0026lt;!-- v-on:increment 설정으로 자식에서 전달된 이벤트 수신하여 incrementTotal 메서드 호출 (부모 컴포넌트 입장의 이벤트 수신) --\u0026gt; 5 \u0026lt;/div\u0026gt; 6 7 \u0026lt;script\u0026gt; 8 Vue.component(\u0026#39;button-counter\u0026#39;, { 9 template: \u0026#39;\u0026lt;button v-on:click=\u0026#34;incrementCounter\u0026#34;\u0026gt;{{ counter }}\u0026lt;/button\u0026gt;\u0026#39;, // 자식 컴포넌트의 click 이벤트 처리 10 data: function () { 11 return { 12 counter: 0 13 } 14 }, 15 methods: { 16 incrementCounter: function () { 17 this.counter += 1 18 this.$emit(\u0026#39;increment\u0026#39;) // 부모로 전달될 수 있도록 \u0026#39;increment\u0026#39; 이벤트 호출 19 } 20 }, 21 }) 22 23 new Vue({ 24 el: \u0026#39;#counter-event-example\u0026#39;, 25 data: { 26 total: 0 27 }, 28 methods: { 29 incrementTotal: function () { 30 this.total += 1 31 } 32 } 33 }) 34 \u0026lt;/script\u0026gt; 35    동일 레벨 컴포넌트간의 통신 동일 컴포넌트간의 직접적인 통신 방법은 제공되지 않는다.\n 동일한 Parent를 가지는 Child 간의 통신은 Child \u0026gt; Parent \u0026gt; Child 방식으로 통신을 해야 한다. 상/하위 관계가 아닌 경우는 Event Bus 를 활용해야 한다. 이 때는 화면과 연동되는 Vue 인스턴스가 아닌 빈 인스턴스를 하나 더 만들어서 Event Bus 용도로 사용하면 된다. 1 \u0026lt;script\u0026gt; 2 var eventBus = new Vue(); // Event Bus로 활용하기 위한 별도의 Vue 인스턴스 생성 3 4 // 화면 처리용 Vue 인스턴스 5 new Vue({ 6 // ... 7 }) 8 ... 9 // 데이터를 보낼 컴포넌트에서 `$emit` 사용 10 eventBus.$emit(\u0026#39;refresh\u0026#39;, 10); 11 ... 12 // 데이터를 받는 컴포넌트에서 `$on` 사용, 단 Event Bus의 이벤트 수신은 라이프사이클 함수에서 처리 13 new Vue({ 14 created: function() { 15 // Vue created event hook에서 Event Bus 수신 처리 정의 16 eventBus.$on(\u0026#39;refresh\u0026#39;, function(data) { 17 console.log(data); // 10 18 }); 19 } 20 }) 21 \u0026lt;/script\u0026gt; 22  만일 Event Bus의 콜백 함수 내에서 해당 메서드를 참고할 경우는 vm사용 1 \u0026lt;script\u0026gt; 2 new Vue({ 3 methods: { 4 callAnyMethod() { // Event Bus에서 호출할 Vue 인스턴스내의 메서드 5 // ... 6 } 7 }, 8 created() { 9 var vm = this; // Vue 인스턴스를 vm에 설정 10 eventBus.$on(\u0026#39;refresh\u0026#39;, function(data) { 11 console.log(this); // 여기서의 this는 이벤트 버스용 인스턴스를 가리킴 12 vm.callAnyMethod() // vm은 현재 인스턴스를 가리킴 13 }); 14 } 15 }) 16 \u0026lt;/script\u0026gt; 17   자바스크립트에서의 this는 상황에 따라서 다른 문맥객체로 동작한다. 위의 예제에서도 굳이 this를 vm이라는 변수로 설정해 놓는 이유도 외부 메서드와 내부 메서드의 문맥객체가 다르기 때문이다. 일반적으로 this는 아래와 같은 상황들에서 다른 문맥객체로 처리된다. - 함수 실행 : this는 전역 객체 문맥을 가진다. (브라우저라면 아마도 window 객체일 것이다) - 엄격모드에서의 함수 실행 : this는 undefined가 된다. - 메서드 실행 : this는 메서드를 소유하고 있는 객체로서의 문맥을 가진다. - 생성자 실행 : this는 새롭게 인스턴싱된 객체로서의 문맥을 가진다. - \u0026hellip; 실행되는 상태에 따라서 this는 의미가 다른 문맥을 가르키게 되므로 항상 이 부분을 조심해야 한다.\n Vue Routers Vue Router는 Vue 코어 라이브러리와 함께 공식 라이브러리로 제공되고 있다. 주로 Vue를 이용해서 SPA (Single Page Application) 어플리케이션을 작성할 때 사용된다.\n설치는 CDN과 NPM 모두 지원한다.\n CDN 설치 \u0026lt;script src=\u0026#34;https://unpkg.com/vue-router/dist/vue-router.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;  NPM 설치 npm install vue-router --save   Vue 라우터는 기본적으로 'Root URL'/#/'Router name' 구조를 가진다.\nexample.com/#/user 위의 구조에서 기본 사용되고 있는 \u0026ldquo;#\u0026ldquo;을 제거하고 싶은 경우는 아래와 같이 속성을 지정하면 된다.\nnew VueRouter({ mode: \u0026#39;history\u0026#39; })   Nested Router 라우터를 기준으로 화면을 이동할 때 Nested Router를 이용해서 지정된 하위 컴포넌트를 표시할 수 있다. 물론 컴포넌트의 구조는 Parent - Child 구조여야 한다. 1 ... 2 \u0026lt;!-- localhost:5000 --\u0026gt; 3 \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; 4 \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; 5 \u0026lt;/div\u0026gt; 6 7 \u0026lt;!-- localhost:5000/home --\u0026gt; 8 \u0026lt;div\u0026gt; 9 \u0026lt;p\u0026gt;Main Component rendered\u0026lt;/p\u0026gt; 10 \u0026lt;app-header\u0026gt;\u0026lt;/app-header\u0026gt; 11 \u0026lt;/div\u0026gt; 12 ... 13 \u0026lt;script\u0026gt; 14 ... 15 // \u0026#39;localhost:5000/home\u0026#39;에 접근하면 Main과 Header 컴포넌트 둘다 표시된다. 16 { 17 path : \u0026#39;/home\u0026#39;, 18 component: Main, 19 children: [ 20 { 21 path: \u0026#39;/\u0026#39;, 22 component: AppHeader 23 }, 24 { 25 path: \u0026#39;/list\u0026#39;, 26 component: List 27 }, 28 ] 29 } 30 ... 31 \u0026lt;/script\u0026gt; 32 \n Named Views 특정 URL로 이동했을 때 여러 개의 컴포넌트를 동시에 표현할 수 있는 방법이다. 1 ... 2 \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; 3 \u0026lt;router-view name=\u0026#34;appHeader\u0026#34;\u0026gt;\u0026lt;/router-view\u0026gt; 4 \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; 5 \u0026lt;router-view name=\u0026#34;appFooter\u0026#34;\u0026gt;\u0026lt;/router-view\u0026gt; 6 \u0026lt;/div\u0026gt; 7 ... 8 { 9 path : \u0026#39;/home\u0026#39;, 10 // Named Router 11 components { 12 appHeader: AppHeader, 13 default: Body, 14 appFooter: AppFooter 15 } 16 } 17 ... 18 \u0026lt;/script\u0026gt; 19 \n Nested Router vs. Named Views\n 특정 URL에 지정된 1개 이상의 컴포넌트가 여러 개의 하위 컴포넌트를 갖는 것을 Nested Router라고 한다. 특정 URL에 여러 개의 컴포넌트를 영역 별로 지정해서 렌더링하는 것을 Named View라고 한다.   [ Nested Routers vs. Named Views ]  HTTP 통신 Vue에서 HTTP 통신을 위해서 가장 많이 사용하는 라이브러리는 Axios로 CDN과 NPM 설치 방식을 모두 지원하며 사용하기 편리한 API와 속성들이 많다. 기본적으로 Promise 기반이기 때문에 코드를 간결하게 작성할 수 있다.\n CDN 설치 \u0026lt;script src=\u0026#34;https://unpkg.com/axios/dist/axios.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;  NPM 설치 npm install axios   실제 사용 방법은 다음과 같다.\n... methods: { fetchData: function() { axios.get(\u0026#39;URL 주소\u0026#39;) .then(res =\u0026gt; { console.log(res.data) }) } } ...  좀 더 자세한 설명과 샘플은 아래의 참고자료 참고\nVue Template 템플릿은 Vue에서 화면을 표현하기 위해서 제공되는 문법으로 Vue 인스턴스에서 관리하는 데이터와 화면과의 연계를 위한 데이터 바인딩(Data Binding)과 화면의 조작을 위한 지시자(Directive)로 나뉜다.\n Data Binding \u0026quot;{{ ... }}\u0026quot;를 활용해서 인스턴스의 data, computed, props 속성들을 연결할 수 있다. 또한 간단한 자바스크립트 표현식도 사용할 수 있다. \u0026lt;div\u0026gt;{{ str }}\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;{{ number + 1 }}\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;{{ message.split(\u0026#39;\u0026#39;).reverse().join(\u0026#39;\u0026#39;) }}\u0026lt;/div\u0026gt;  Directive HTML 태그의 속성에 v- 접두사가 붙은 특별한 속성으로 화면의 DOM 조작을 쉽게할 수 있는 문법들을 제공한다. \u0026lt;!-- 조건문 처리 : seen의 true/false에 따라 p 태그의 표시여부 결정 --\u0026gt; \u0026lt;p v-if=\u0026#34;seen\u0026#34;\u0026gt;Now you see me\u0026lt;/p\u0026gt; \u0026lt;!-- 화면에 a 태그가 표시되는 시점에 Vue 인스턴스에서 관리하는 url 데이터 값을 href 속성 값으로 바인딩 처리 --\u0026gt; \u0026lt;a v-bind:href=\u0026#34;url\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;!-- button의 클릭 이벤트로 doSomething이라는 메서드를 실행 --\u0026gt; \u0026lt;button v-on:click=\u0026#34;doSomething\u0026#34;\u0026gt;\u0026lt;/button\u0026gt;  Filters 화면에 표시되는 텍스트의 형식을 편하게 설정할 수 있도록 하는 기능으로 파이프 문자(|)를 이용해서 여러 개의 필터를 적용할 수 있다. 1 \u0026lt;!-- message 값에 capitalize 필터를 적용하여 첫 글자를 대문자로 변경 --\u0026gt; 2 {{ message | capitalize }} 3 ... 4 \u0026lt;script\u0026gt; 5 new Vue({ 6 filters: { 7 capitalize: function(value) { 8 if (!value) return \u0026#39;\u0026#39;; 9 value = value.toString(); 10 return value.charAt(0).toUpperCase() + value.slice(1); 11 } 12 } 13 }) 14 \u0026lt;/script\u0026gt; 15  위의 샘플은 \u0026ldquo;message\u0026rdquo; 데이터를 출력하는데 \u0026ldquo;capitalize\u0026rdquo;라는 Vue 인스턴스에 정의된 Filters 메서드를 호출해서 첫 글자를 대문자로 변경한 후에 이 결과를 출력하도록 처리하는 방식이다.  Single File Component UI에 대해서 특정 기능을 제공하는 컴포넌트로 하나의 파일 내에서 HTML, CSS, JS 코드를 모두 지원한다. 확장자는 .vue를 사용하고 HTML 파일 내에서 Vue 개발을 진행했을 때의 한계를 극복할 수 있는 방법이다.\nHTML 파일 내에서 개발할 때의 한계점들은 다음과 같다.\n 모든 컴포넌트의 유일한 식별을 위해서 공유의 이름을 지정해야 한다. js 파일에서 template 안의 HTML 문법 강조가 되지 않는다. js 파일에서 css 스타일 작업이 거의 불가능하다. ES5를 이용해서 계속 앱을 작성할 경우 Babel 빌드가 지원되지 않는다.  기본적인 골격은 다음과 같다.\n\u0026lt;template\u0026gt; \u0026lt;!-- HTML --\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; // Javascript \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; /* CSS */ \u0026lt;/style\u0026gt; Vue Loader Single File Component로 작성된 컴포넌트를 브라우저에서 실행가능한 자바스크립트 파일로 변환해 주는 Webpack Loader로 Vue Loader를 사용하면 다음과 같은 장점이 있다.\n ES6 지원 \u0026lt;style\u0026gt;, \u0026lt;template\u0026gt;에 대한 각각의 Webpack Loader 지원 (eg. sass, jade, \u0026hellip;) .vue 컴포넌트의 범위(scope)로 대상으로 하는 css 스타일 지원 Webpack 모듈 번들링에 대한 지원과 의존성 관리 제공 개발 시에 HMR (Hot Module Replacement) 지원  Vue CLI Vue CLI3는 Vue.js 개발을 위한 시스템으로 Vue.js Core에서 공식으로 제공하는 CLI (Command Line Interface)로 Vue 어플리케이션 개발에 집중할 수 있도록 프로젝트 생성을 위한 명령어 도구로 Node 기반에서 동작하므로 당연히 Node가 사전 설치가 되어 있어야 한다.\n또한 Vue 생태계에서 표준 툴을 목표로 하고 있다. 프로젝트를 구성하고 스캐폴딩에 도움을 주는 것이기 때문에 반드시 필요한 것은 아니지만 Vue.js와 관련된 오픈소스들은 대부분 Vue CLI를 통해서 설치가 가능하기 때문에 사용하는 것이 좋다.\n주요 사용은 다음과 같다.\n vue 명령어  $ vue create : 프로젝트 생성 $ vue ui : 제공되는 ui를 통해서 프로젝트 관리  CLI Service : webpack, webpack-dev-server 위에 구축되며 CLI Plugin을 실행하는 핵심 서비스와 webpack에 대한 설정을 포함하고 있다. 즉, webpack을 기반으로 어플리케이션의 개발, 빌드, 실행을 처리한다. CLI Plugin : Babel, Typescript, ESLint, e2d Test 등과 같은 선택적으로 설치가 필요한 Plugin을 말하며, 프로젝트 생성 시점에 포함하거나 이후에 포함시킬 수 있다.  자세한 내용은 아래의 참고자료를 참고하면 된다.\nVirtual DOM React처럼 Vue도 Virtual DOM을 사용한다. Virtual DOM은 화면을 위한 기반 기술로 화면의 DOM에 추가/삭제 등의 변경이 발생하면 화면을 다시 그리는 것이 아니라 자바스크립 상에 객체로 DOM의 구조를 설정해 놓고, 실제 변경이 발생한 경우에 그 부분만 화면을 그릴 수 있도록 해서 브라우저가 화면을 다시 그리는 부하를 줄이는 기법이다.\n동작하는 방법은 아래와 같이 추상적으로 예상해 볼 수 있다.\n DOM이 Load되면 DOM의 Tag들을 Javascript JSON 객체로 복제한다. Vue의 변경에 대한 작업은 모두 복제된 JSON 객체를 대상을 이루어진다. JSON 객체에서 Diff 정보를 추출한다. Diff 정보를 기준으로 실제 DOM의 어떤 부분이 변경되었는지를 확인하고 해당 부분만 갱신한다.  자세한 샘플은 아래의 참고자료를 참고하면 된다.\n참고자료  Vue.js 공식문서 Cracking Vue.js Wiki - MVVM Understanding the Virtual DOM Vue.JS - Vue-CLI3 시작하기 Vue.js에서 axios를 사용하여 서버통신하는 방법 Vue Router  "
},
{
	"uri": "http://ccambo.github.io/Git/Tips/how-to-change-users/",
	"title": "How to Change Users",
	"tags": ["Git", "Change Users"],
	"description": "Git 사용 중에 사용자 변경 관련 오류를 해결하는 방법을 정리합니다.",
	"content": " 대부분의 경우는 단일 사용자로 Git를 운영하겠지만 다양한 이유에 의해서 Git 사용자를 변경해야 하는 상황이 존재한다.\n여기서는 이런 문제를 해결하는 방법에 대해서 알아본다.\n발생 상황 git 설치 후에 기본 환경 설정을 했을 것이다.\n git 환경 설정  # 전역 설정인 경우 $ git config --global user.name \u0026#34;user name\u0026#34; $ git config --global user.email \u0026#34;user email\u0026#34; # git 단위 설정인 경우 $ git config user.name \u0026#34;user name\u0026#34; $ git config user.email \u0026#34;user email\u0026#34;   이런 상황에서 지정한 사용자로 Git에 로그인 한 후에 다른 사용자를 사용해서 push를 하면 다음과 같은 오류가 발생하게 된다.\n 다른 사용자로 로그인된 상태에서 git push 오류 발생  $ git push origin master # terminal에서 실행한 것과 VSCode와 같은 IDE에 연동한 경우도 동일한 상황이 발생한다. remote: Permission [git_url.git] denied to [user_id] fatal: unable to acess `[git_url]`: The requested URL returned error: 403 ...   오류 메시지 내용은 해당 사용자로 remote repository에 push할 권한이 없다는 것이다.\n해결 방법 구글을 검색해 보면 대부분 아래와 같은 해법을 제시한다.\n 사용할 git 프로젝트에서 config 설정을 사용자에 맞도록 변경하면 된다.  git 환경 프로젝트 단위 설정  $ git config user.name \u0026#34;new user name\u0026#34; $ git config user.email \u0026#34;new user email\u0026#34;     권장하는 방식으로 해 봐도 동일한 오류가 발생한다. (당연히 이미 로그인 사용자 정보를 기준으로 하므로 설정을 바꾼다고 해서 로그인 정보가 변경되지는 않는다) ssh 키 관련해서 여러 가지 처리를 제시하는 것도 있지만, 제대로 안되는 상황이 발생한다.  환경 설정을 바꿨기 때문에 지금 push 하려는 사용자와 로그인 사용자가 달라졌으므로 로그인을 다시 물어봐야 할 것 같은데, 실제로는 로그인을 다시 물어보지 않는다.\n의외로 쉽게 해결하는 방법은 다음과 같다.\n Mac 환경\n Spotlight 검색 등으로 키 체인 접근 앱을 실행한다. [ Spotlight 검색 ] \n 키 체인 접근 앱에서 로그인을 선택하고 github.com을 찾아서 더블클릭한다. [ Key chain access ] \n 로그인 정보 창에서 계정과 암호를 변경하고 저장한다. [ Github 로그인 변경 ] \n  Windows 환경\n 제어판 \u0026gt; 사용자 계정 \u0026gt; 자격 증명 관리자를 실행한다. windows 자격 증명 항목의 github 관련 정보를 수정한다. 위와 같이 설정한 후에 다시 push를 실행하면 잘 처리가 된다.   결론 오류의 원인이 로그인된 사용자 정보를 그대로 사용하려고 하는 것이기 때문에 터미널을 사용하던 VSCode와 같이 IDE에 연동해서 사용하던 이미 사용했던 로그인 정보를 삭제 또는 변경해서 로그인을 다시하면 쉽게 해결이 가능하다.\n"
},
{
	"uri": "http://ccambo.github.io/Git/Submdule/what-is-the-submodule/",
	"title": "What is the submodule",
	"tags": ["Git", "Submodule"],
	"description": "Git의 Submodule에 관련된 내용을 정리합니다.",
	"content": " 아래의 내용은 정리하면서 검증한 부분도 있지만, 검증이 되지 않고 정리된 내용도 있을 수 있으므로, 반드시 관련된 정보를 추가로 검색하여 검증해야 한다.\n Submodule? Git 프로젝트는 하나의 독립된 라이브러리라고 생각할 수 있다. 따라서 특정 프로젝트를 진행할 때 또 다른 프로젝트를 내부적으로 사용해야하는 경우가 빈번하게 발생할 수 있다. 일반적으로 이런 상황에서는 필요한 라이브러리의 특정 버전을 설치하거나 소스를 복사해서 사용하는 방법을 사용하는데 이에 따른 버전관리나 소스의 변경등에 대한 대처가 만만치 않다.\nGit와 Submodule을 사용하면 Git Repository 내에 또 다른 독립적인 Repository를 운영하는 구조를 만들 수 있다. 당연히 각 Repository는 독립적으로 관리된다.\n이런 상황이 새로운 것일까? Node 환경이라면 이미 npm을 이용해서 package를 관리하며 사용하고 있다. 그런데 가져다 쓸 패키지가 git에 repository로만 존재하는 경우라면 어떻게 해야할 까? 이런 상황에 대체하기 위한 것이 submodule이고 정리하면 \u0026ldquo;submodule은 git repository 하위에 다른 git repository를 관리하기 위한 도구\u0026rdquo;  라고 생각하면 된다. 자세한 내용은 Pro Git의 내용을 참고!\n 사용법 정리 기본 옵션들 git submodule에 대한 공식 옵션은 다음의 명령으로 확인 가능하다.\n git submodule 도움말  $ git submodule --help   main project와 submodule project 관계 main project에 submodule을 추가하면 submodule들을 관리하기 위한 .gitmodules  파일이 생성되고 여기에 submoudle에 대한 폴더와 repository 정보가 관리되며 main project는 추가된 submodule에 대한 commit point를 바라보고 있게 된다.\n따라서 main project와 submodule 간의 처리는 아래와 같은 순서에 주의해야 한다.\n clone / pull / update : 리모트에서 로컬로 데이터를 가져올 경우는 Parent 먼저  처리 후 submodule을 처리해야 한다. commit / push : 로컬 commit과 리모트로 데이터를 전송하는 경우는 submodule 먼저  처리 후 Parent를 처리해야 한다.  main project가 submodule에 대한 commit point를 연계하고 있기 떄문에 위의 순서가 맞지 않으면 잘못된 submodule의 commit point를 바라보게 되므로 문제가 발생할 수 있다.\n submodule 추가  submodule 추가 (Main Project Root 폴더)  $ git submodule add [-b branch_name] \u0026lt;repository address\u0026gt; [path] # path를 생략하면 현재 경로 밑으로 repository 이름으로 생성된다.   정상적으로 추가되면 main project 경로에 .gitmodules 파일이 생성되며, 내용은 아래와 같이 구성된다.\n .gitmodules 파일 내용 (Main Project Root 폴더)  [submodule \u0026#34;themes/hugo-theme-docdock\u0026#34;] path = themes/hugo-theme-docdock url = https://github.com/vjeantet/hugo-theme-docdock.git   위와 같이 Root Repository (여기서는 Hugo로 만든 사이트) 를 기준으로 경로와 git repository url이 관리되고 있는 것을 확인할 수 있다.\nsubmodule이 추가된 것은 main project가 변경된 것을 의미하기 때문에 commit을 수행해 줘야 한다. 특정 branch로 지정할 경우는 -b \u0026lt;branch name\u0026gt;을 사용하면 된다. 또한 나중에 submodule에 대한 branch를 설정할 경우는 아래와 같이 처리할 수도 있다.\n submodule에 대한 Branch 설정 (Main Project Root 폴더)  $ git config -f .gitmodules submodule.\u0026lt;submodule path\u0026gt;.branch \u0026lt;branch name\u0026gt;   submodule 상태 확인 기본적인 git 상태 확인은 아래의 명령을 사용하며 submodule과 연동해서 사용할 수 있다.\n submodule 상태 확인 (Main Project Root 폴더)  # main project 상태 확인 $ git status # submodule 상태 확인 $ git submodule status # main project 상태확인에 submodule 정보 추가해서 보기 설정 $ git config status.submodulesummary 1   main project에서 바라보는 submodule 상태  main project에서 바라보는 submodule 상태 (Main Project Root 폴더)  $ git diff --cached \u0026lt;submodule path\u0026gt; new file mode 160000 index 0000000..51dbdcf --- /dev/null +++ b/themes/hugo-theme-learn @@ -0,0 +1 @@ +Subproject commit 51dbdcf4aaef01d02e78a6ea76b2a6fde5842b55   위의 내용을 검토해 보면 다음과 같은 특징이 존재한다.\n mode 160000은 일반적인 파일이나 디렉토리가 아니라는 의미를 가진다. Subproject commit 51dbdcf4aaef01d02e78a6ea76b2a6fde5842b55는 main project가 submodule repository의 51dbdcf4aaef01d02e78a6ea76b2a6fde5842b55 commit 정보를 바라보고 있다는 의미를 가진다.  Detached HEAD 문제 Detached HEAD 문제란 submodule update 명령이 수행되면 해당 submodule이 어떤 branch에도 속하지 않는 분리된 HEAD 정보를 가지는 상태를 말하는 것으로 branch를 지정해 줘야 한다. 따라서 아래와 같이 각 단계별 명령을 수행할 때 지정해 주는 것이 좋다.\n Detach HEAD 방지 처리 (Main Project Root 폴더)  # 처음 clone할 때 $ git submodule init $ git submodule udpate $ git submodule foreach git checkout \u0026lt;branch name\u0026gt; # pull/update할 때 $ git pull $ git submodule update --remote --merge # push할 때 $ git push --recurse-submodules=check   git detached HEAD에 대한 내용은 정보를 참고하고, submodule과 detached HEAD에 대한 내용은 정보를 참고하면 된다.\n 단축 명령 및 Config 설정 위에서 알아본 명령들을 별칭(Alias) 등록을 통해서 단축 명령으로 수행할 수도 있다.\n Alias 기준 단축 명령 등록 (Main Project Root 폴더)  # git sdiff 단축 정의 $ git config alias.sdiff \u0026#39;!\u0026#39;\u0026#34;git diff \u0026amp;\u0026amp; submodule foreach \u0026#39;git diff\u0026#39;\u0026#34; # git spush 단축 정의 $ git config alias.spush \u0026#39;push --recurse-submodules=check\u0026#39; # git supdate 단축 정의 $ git config alias.supdate \u0026#39;submodule update --remote --merge\u0026#39;   main project에 아래와 같이 정보를 설정해 두면 활용하기 쉽다.\n main project에 submodule연계 환경 설정 (Main Project Root 폴더)  # login $ git config credential.helper cache # status $ git config status.submodulesummary 1 # diff $ git config diff.submodule log   이미 submodule을 포함하고 있는 Repository 활용하기 clone and update submodules  Parent git project clone : .gitmodules 파일이 존재하며, 파일내에 어떤 폴더에 어떤 git repository를 사용하는지에 대한 정보를 알 수 있다.  Parent 프로젝트 Clone  $ git clone \u0026lt;main project repository\u0026gt;   \n submodule clone  submodule 프로젝트들 Clone (Clone된 Main Project Root 폴더)  $ git submodule init # submodule 초기화 $ git submodule update # submodule 갱신(다운로드 - Detached HEAD 상태로 어떤 branch에도 속하지 않는 상태) $ git submodule foreach git checkout \u0026lt;branch name\u0026gt; # 지정한 branch로 설정   \n  위의 clone 과정을 한번에 처리할 수도 있다. $ git clone \u0026ndash;recurse-submodules \u0026lt;main project repository\u0026gt; $ git submodule foreach git checkout \n 이미 로컬에 submodule이 존재하는 경우 갱신  이미 존재하는 submodule 갱신 (Main Project Root 폴더)  $ git submodule update --remote --merge   commit and push submodules  만일 새로운 branch로 작업하는 경우  새로운 Branch로 작업 (Main Project Root 폴더)  $ git submodule foreach git checkout -b \u0026lt;feature name\u0026gt;   \n 변경된 코드들 commit  변경된 코드들 Commit (Main Project Root 폴더)  $ git submodule foreach git add -A . $ git submodule foreach git commit -am \u0026#34;commit message\u0026#34; $ git submodule foreach git checkout \u0026lt;branch name\u0026gt; $ git submodule foreach git merge \u0026lt;feature name\u0026gt;   \n push submodules  Submodule Push (Main Project Root 폴더)  $ git submodule foreach git push   \n commit and push main project  Main Project Push (Main Project Root 폴더)  $ git commit -am \u0026#34;commit message\u0026#34; $ git push \u0026ndash;recurse-submodules=check   \n  위에서 언급한 것과 같이 push를 할 때는 반드시 submodule들을 먼저 처리하고 main project를 처리  해야 한다. 따라서 submodule들이 모두 push되었는지를 확인해야 한다.\n Main Project Push 전에 모든 Submodule들이 Push된 상태인지 확인 (Main Project Root 폴더)  $ git push --recurse-submodules=check # submodule들이 모두 push된 상태인지를 검사하고 확인되면 push 처리 $ git push --recurse-submodules=on-demand # submodule들을 모두 push하고 성공하면 push 처리   매번 명령어를 지정해서 처리하는 것을 항상 처리할 수 될 수 있도록 하기 위해서는 아래와 같이 설정으로 처리해 두면 된다.\n 항상 처리될 수 있도록 설정 (Main Project Root 폴더)  $ git config push.recurseSubmodules check $ git config push.recurseSubmodules on-demand   submodule 제거  .gitmodules 파일에서 대상 submodule 정보를 삭제한다. 변경된 내용을 stage 처리 한다.  변경사항 Stage 처리 (Main Project Root 폴더)  $ git add .gitmodules   \n .git/config 파일에서 대상 submodule 정보를 삭제한다.\n git 에서 cached 인덱스 정보를 제거한다.  Cached Index 삭제 (Main Project Root 폴더)  $ git rm \u0026ndash;cached \u0026lt;path to submodule\u0026gt; # 경로 맨 뒤의 \u0026#39;/\u0026#39;는 사용하지 않는다.   \n ./git/modules 폴더에서 대상 submodule 폴더 정보를 삭제한다.  git modules 에서 Submodule 경로 삭제 (Main Project Root 폴더)  $ rm .git/modules/\u0026lt;path to submodule\u0026gt; # 경로 맨 뒤의 \u0026#39;/\u0026#39;는 사용하지 않는다.   \n 변경된 내용을 commit 한다.\n 제거된 submodule 폴더를 삭제한다.  제거된 Submodule 폴더 삭제 (Main Project Root 폴더)  $ rm -rf \u0026lt;path to submodule\u0026gt;   \n  위의 내용은 기본적인 git 명령을 사용한 것이고 submodule 명령을 통하면 다음과 같이 더 간단하게 처리가 가능할 수 있다.\n git에서 submodule 관련 정보 삭제  Git의 Submodule 관련 정보 삭제 (Main Project Root 폴더)  $ git submodule deinit \u0026lt;path to submodule\u0026gt;   \n git에서 submodule 삭제  Git의 Submodule 삭제 (Main Project Root 폴더)  $ git rm \u0026lt;path to submodule\u0026gt;   \n 변경 내용 commit\n submodule 폴더 삭제  git modules 에서 Submodule 경로 삭제 (Main Project Root 폴더)  $ rm .git/modules/\u0026lt;path to submodule\u0026gt; # 경로 맨 뒤의 \u0026#39;/\u0026#39;는 사용하지 않는다.   \n  참고자료  git-scm Book Chapter 6. Git Tools - Submodule How to effectively delete a git submodule  "
},
{
	"uri": "http://ccambo.github.io/Git/Basics/",
	"title": "Basics",
	"tags": [],
	"description": "",
	"content": " Basics 이 문서에서는 Git 사용에 필요한 기본적인 정보들을 정리하고 있습니다.\n "
},
{
	"uri": "http://ccambo.github.io/FunnyLab/Blogging/",
	"title": "Blogging",
	"tags": [],
	"description": "",
	"content": " Blogging 이 문서에서는 Hugo 및 Hexo 블로그 구성에 필요한 정보들을 정리하고 있습니다.\n 댓글 시스템 utterances로 변경  기존 Disqus 댓글 시스템의 문제점으로 Github연동형 댓글 시스템인 utternaces로 변경한 내용을 정리합니다.\n OGP API 서버 Heroku에 배포하기  이 문서는 블로그에서 외부 게시글에 대한 미리보기를 작성하면서 Open Graph를 적용하는 방법을 정리한 것입니다. Hugo나 Hexo를 기준으로 적용하는데 필요한 OGP 처리용 API Server를 구성하는 내용이므로 OGP에 대한 상세한 내용은 아래의 참고 자료를 활용하시기 바랍니다. 기본적인 개발 환경은 이미 활용하는 것으로 가정하고 git / vscode / macbook을 기준으로 설명합니다 OGP란? 오픈그래프 (Open Graph)는 HTML 메타 태그의 종류 중의 하나로 사용성에 약간의 차이를 가진다. SNS에서 그 개념이 시작되었는데, SNS에 링크를 걸어 놓으면 이 링크가 어떤 데이터를 가지고 있는지를 알 수 있는 방법이 없기 때문에 링크에 대한 미리보기로써 이미지, 설명, 제목등을 나타내기 위한 태그들이다.\n "
},
{
	"uri": "http://ccambo.github.io/Cloud/Concepts/",
	"title": "Concepts",
	"tags": [],
	"description": "",
	"content": " Concepts Cloud와 연계되는 개념들을 정리합니다.\n Edge Computing  Edge Computing에 대한 내용을 정리합니다.\n "
},
{
	"uri": "http://ccambo.github.io/Git/",
	"title": "Git",
	"tags": [],
	"description": "",
	"content": " Git 관련 정보들 정리 이 문서에서는 Git 사용에 필요한 정보들을 정리하고 있습니다.\n Basics   Basics 이 문서에서는 Git 사용에 필요한 기본적인 정보들을 정리하고 있습니다.  Submodule   Submodule 이 문서에서는 Git의 Submodule에 관련된 정보들을 정리하고 있습니다. What is the submodule Git의 Submodule에 관련된 내용을 정리합니다.  Tips   Tips 이 문서에서는 Git 사용 중에 발생한 오류들의 해결 방법이나 유용한 정보들을 정리하고 있습니다. How to Change Users Git 사용 중에 사용자 변경 관련 오류를 해결하는 방법을 정리합니다.  "
},
{
	"uri": "http://ccambo.github.io/Dev/Vue/",
	"title": "Vue",
	"tags": [],
	"description": "",
	"content": " Vue Vue에 대한 소개 및 사용하는데 필요한 정보들을 정리합니다.\n Vue 키 포인트 소개  프로젝트에 Vue를 도입한 결정적인 이유\n Vue 기본 개념  Vue.js에 대한 간략한 기본 개념 소개\n Vuetify v2.x 업그레이드  Vue 및 Vuetify와 관련된 프로젝트를 v2.x 버전으로 업그레이드해서 작업할 때 발생하는 문제점들을 정리한다.\n Vuex의 Store란 무엇일까?  Vue 개발에서 상태를 관리해 주는 기능을 제공해 주는 것이 Vuex이고 어플리케이션의 모든 컴포넌트들에 대한 중앙 집중식 저장소의 역할 및 관리 를 담당한다. Vuex는 상태관리 패턴 + 라이브러리이며, Vue의 공식 툴이며 ES2015 문법을 기준으로 한다. Promise를 지원하지만, 혹시 지원하지 못하는 브라우저를 생각해야 한다면 es6-promise도 설치해 줘야 한다. Vuex가 없다면 컴포넌트간의 데이터(상태)를 주고 받기 위해서 부모는 자식에서 props를 통해서 전달하고, 자식은 부모에게 Emit event 방식을 사용해서 처리해야 한다.\n vue-property-decorator 정리  현재 진행 중인 Vue.js + Typescript 기반의 프로젝트에서 컴포넌트 구성에 필요한 부분을 정리한 것으로 Typescript로 구성하면 자바스크립트로 어떻게 구성되는지를 비교하면서 진행하도록 한다. 특이한 코드 설정 (readonly, !) Typescript를 사용하면서 \u0026lsquo;?\u0026rsquo; 는 생략 가능 또는 null / undefined도 가능하다라는 코드는 많이 봤을테지만 vue-property-decorator 샘플들을 보면 \u0026lsquo;readonly, !:\u0026rsquo; 와 같은 생소한 코드를 보게 된다. readonly 대상 멤버를 읽기 전용으로 한정하겠다는 한정자 (OOP 언어에서는 많이 사용)로 Vue에서 Prop이나 Model 등에 readonly를 한정했을 떄 할당을 하면 오류가 발생하게 된다.\n "
},
{
	"uri": "http://ccambo.github.io/Dev/Go/How-to-use-mongodb-with-go/",
	"title": "Golang으로 MongoDB 연결해 보기",
	"tags": ["MongoDB", "mongo-driver", "docker-compose"],
	"description": "MongoDB를 Docker Compose 로 구동한 후에 Go Package를 이용해서 MongoDB에 접속하는 방법을 정리하고 있습니다.",
	"content": "  이 문서에서는 아주 간단하게 Docker-compose를 이용해서 MongoDB를 구동하고 Golang을 통해서 연결하는 부분에 대해서 정리하고 있습니다. 환경은 맥북, VSCode, Golang, Docker 등이 이미 설치되어 있는 것을 기준으로 합니다.\n 간단한 MongoDB 정리 RDBMS와의 비교 RDB vs. NoSQL (MongoDB)   RDBMS MongoDB     Database Database   Table Collection   Tuple/Row Document   Column Key/Field   Table Join Embedded Documents   Primary Key Primary Key (_id)    특징과 장/단점 주요 특징들은 다음과 같다.\n Document-Oriented Storage : Database \u0026gt; Collections \u0026gt; Documents 구조로 Document는 key-value 형태의 BSON (Binary JSON)으로 되어 있다. Full Index Support : 다양한 인덱싱을 제공한다.  Single Field Indexes : 기본적인 인덱스 타입 Compound Indexes : RDBMS의 복합 인덱스 타입 Multikey Indexes : Array에 매칭되는 값이 하나라도 있으면 인덱스에 추가하는 인덱스 타입 Geospatial Indexes and Queries : 위치기반 인덱스와 쿼리 지원 Text Indexes : String에 대한 인덱스 지원 Hashed Indexes : Btree 인덱스가 아닌 Hash 타입의 인덱스도 지원  Replication \u0026amp; High Availablity : 간단한 설정을 통해서 데이터 복제를 지원하므로 가용성이 향상된다. Auto-Sharding : 자동으로 데이터를 분산해서 저장하며, 하나의 컬랙션처럼 사용할 수 있도록 수평적 확장 기능을 제공한다. Querying (Document based query) : 필터링, 수집, 정렬, 정규표현식 등의 다양한 쿼리문 지원 Fast In-Place Updates : 고성능 atomic operation 지원 Map/Reduce : 맵리듀스 지원 (map과 reduce 함수의 조합을 통해서 분산/병렬 시스템 운용 지원, 하둡처럼 MR전용 시스템에 비해서는 성능이 떨어진다) GridFS : 분산 파일 저장을 지원하기 때문에 실제 파일이 어디 저장되는지를 알 필요가 없으며 복구도 자동으로 지원된다. Commerical Support : 10gen에서 관리  장점\n데이터를 쌓아놓고 삭제가 필요없는 경우가 가장 적합하다. (ex. 로그 데이터 등)\n Flexibility : Schema-less (or Schema-Free) 라서 어떤 형태의 데이터라도 저장이 가능하다. Performance : Read \u0026amp; Write 성능이 뛰어나다.캐싱이나 많은 트래픽을 감당할때 사용해도 좋다. Scalability : 기본적으로 Scale-out 구조를 채택해서 쉽게 운용이 가능하다. Auto-Sharding 지원 Deep Query Ability : 문서 지향적 Query Language를 사용해서 SQL만큼 강력한 Query성능을 제공한다. Conversion / Mapping : JSON 형태로 저장 (실제는 BSON) 되기 때문에 직관적이고 개발이 편리하다.  단점\n정합성이 요구되어 트랜잭션 관리가 필요한 경우는 부적합하다. (ex. 금융, 회계, 회원정보 등)\n Join이 없다 : JOIN이 필요없도록 데이터의 구조를 잡아야 한다. File 기반이다 : Memroy mapped file 기반의 파일 엔진 DB이며 메모리 관리를 OS에 의존한다. 따라서 메모리 의존성이 있으며 메모리 크기가 성능을 좌우한다. SQL을 완전히 이관할 수 없다 : SQL을 그대로 이전할 수 없으며 맞도록 변환해야 한다. BTree 성능 이슈가 있다 : 인덱스를 BTree 기반으로 하고 있으므로 크기가 커질수록 새로운 데이터를 입력하거나 삭제할 때 성능이 저하된다. 따라서 데이터를 넣어두고 조회만 하는데 적합하다.  메모리 관련 이슈 데이터를 저장할 때 논리적으로 메모리에 먼저 저장하고 일정 주기에 따라서 메모리 블럭들을 디스크로 출력하는데 이 부분을 OS의 의존하고 있다. 실제 메모리가 작아도 OS의 가상메모리 운영 방식에 따라서 운영된다.\n이런 운영 구조 때문에 메모리에서 데이터 블럭을 참조할 때 없다면 \u0026ldquo;Page Fault\u0026rdquo; 오류가 발생하고, 이 상황에서 디스크에서 해당 블록을 찾아서 메모리에 로드하여 처리하게 된다. 이 과정에서 모자라는 메모리 때문에 다른 블럭을 디스크에 쓰고 제거한 후 필요한 블럭을 메모리로 올리는 작업이 처리되기 때문에 디스크 I/O가 발생하므로 성능 저하가 발생할 수 밖에는 없다.\n따라서 메모리 크기가 성능을 좌우한다는 것은 Page Fault 오류의 발생 반도에 근거하고 있다고 보면 된다. 따라서 데이터 설계를 할 때 자주 사용되는 데이터가 메모리에 상주할 수 있도록 key 설계를 하는 것이 매우 중요하다. 또한 테이블을 풀 스캔하는 작업은 무조건 Page Fault를 발생시키게 되므로 이런 경우는 Index Table (Summary Table) 등을 만들어서 운영하는 것이 성능을 위한 방법이라고 할 수 있다.\n주요 용어 Document\nRDBMS의 Tuple / Row와 대응되는 개념으로 Key-Value 쌍으로 구성되며, Value에는 또 다른 document가 설정될 수도 있다. 동적 스키마를 가지고 있기 때문에 같은 Collection (Table) 안에 있는 Document끼리도 다른 스키마를 가질 수 있다. (Free Schema)\n Document 샘플  { \u0026#34;_id\u0026#34;: ObjectId(\u0026#34;5099803df3f4948bd2f98391\u0026#34;), \u0026#34;username\u0026#34;: \u0026#34;Morris\u0026#34;, \u0026#34;language\u0026#34;: { Nuxt: 3, Go: 3, } }    Primary Key\nRDBMS의 Primary Key와 대응되는 개념으로 ObjectId는 12bytes의 16진수 값으로 각 Document의 유일성을 보장하는 역할을 담당한다.\n 4bytes : Timestamp Data 3bytes : Machine id Data 2bytes : MongoDB 서버의 Process id Data 3bytes : Sequenctial number Data  개념적으로는 RDBMS의 auto increment와 비슷한 개념으로 생각하면 될 듯 하다.\n MongoDB에서 Collection에 저장된 각 Document들은 반드시 기본 키 역할을 담당하는 \u0026ldquo;_id\u0026rdquo; 라는 필드를 가져야 한다.\n Collection\nRDBMS의 Table에 대응되는 개념으로 Document의 그룹이며, Document들이 Collection 내부에 위치한다.\nDatabase\nRDBMS의 Database에 대응되는 개념으로 Collection들의 물리적인 컨테이너다. 따라서 각 Database는 물리적인 파일 시스템에 여러 개의 파일로 저장된다.\nMongoDB 실행하기 (docker-compose) MongoDB 자체를 실행하는 것은 그렇게 어렵지 않다. 아래와 같이 아주 단순한 docker-compose.yml을 구성하면 바로 구동된다.\n docker-compose.yml - MongoDB 구성  1version: \u0026#34;3.3\u0026#34; 2services: 3 mongodb: 4 image: mongo:latest # 사용할 Docker Image 5 container_name: mongdb # Docker Container 식별 명 6 restart: always 7 environment: 8 MONGO_INITDB_DATABASE: \u0026#34;사용할 데이터베이스 명 설정\u0026#34; # 정보만 존재하고 실제 데이터가 처리될 때 생성됨. 9 MONGO_INITDB_ROOT_USERNAME: \u0026#34;root 사용자 설정\u0026#34; # 최초 실행되서 DB 구성할 때 사용자 생성됨. 10 MONGO_INITDB_ROOT_PASSWORD: \u0026#34;root 사용바 비밀번호 설정\u0026#34; # 최초 실행되서 DB 구성할 때 사용자 생성됨. 11 volumes: 12 - ./data/mongodb/:/data/db # 로컬 경로를 컨테이너의 볼륨으로 연계 13 ports: 14 - \u0026#34;27017:27017\u0026#34;   위와 같이 구성하고 docker-compose.yml 파일이 존재하는 경로에서 아래의 명령으로 실행하면 된다.\n docker-compose.yml 실행  1$ docker-compose up 2# Background로 실행하는 방법 3$ docker-compose up -d 4# 로그 확인하는 방법 5$ docker-compose logs   로그를 확인해 보면 중간에 root 계정을 생성하는 것을 확인할 수 있으며, 인증 모드로 동작하고 있는 것을 확인할 수 있다.\n 실행 로그 검증  1... 2mongdb | 2020-01-07T10:58:38.416+0000 I INDEX [conn2] index build: done building index user_1_db_1 on ns admin.system.users 3mongdb | Successfully added user: { 4mongdb | \u0026#34;user\u0026#34; : \u0026#34;root\u0026#34;, 5mongdb | \u0026#34;roles\u0026#34; : [ 6mongdb | { 7mongdb | \u0026#34;role\u0026#34; : \u0026#34;root\u0026#34;, 8mongdb | \u0026#34;db\u0026#34; : \u0026#34;admin\u0026#34; 9mongdb | } 10mongdb | ] 11mongdb | } 12... 13mongdb | 2020-01-07T10:58:48.466+0000 I CONTROL [initandlisten] MongoDB starting : pid=1 port=27017 dbpath=/data/db 64-bit host=7531e03b8054 14mongdb | 2020-01-07T10:58:48.466+0000 I CONTROL [initandlisten] db version v4.2.2 15mongdb | 2020-01-07T10:58:48.466+0000 I CONTROL [initandlisten] git version: a0bbbff6ada159e19298d37946ac8dc4b497eadf 16mongdb | 2020-01-07T10:58:48.466+0000 I CONTROL [initandlisten] OpenSSL version: OpenSSL 1.1.1 11 Sep 2018 17mongdb | 2020-01-07T10:58:48.467+0000 I CONTROL [initandlisten] allocator: tcmalloc 18mongdb | 2020-01-07T10:58:48.467+0000 I CONTROL [initandlisten] modules: none 19mongdb | 2020-01-07T10:58:48.467+0000 I CONTROL [initandlisten] build environment: 20mongdb | 2020-01-07T10:58:48.468+0000 I CONTROL [initandlisten] distmod: ubuntu1804 21mongdb | 2020-01-07T10:58:48.468+0000 I CONTROL [initandlisten] distarch: x86_64 22mongdb | 2020-01-07T10:58:48.468+0000 I CONTROL [initandlisten] target_arch: x86_64 23mongdb | 2020-01-07T10:58:48.468+0000 I CONTROL [initandlisten] options: { net: { bindIp: \u0026#34;*\u0026#34; }, security: { authorization: \u0026#34;enabled\u0026#34; } }   좀 더 많은 구성 옵션들과 실행과 관련된 스크립트들 (예를 들어 일반 사용자 추가 등)을 더 설정할 수 있지만, 여기서는 이 정도만 구성해도 충분하다.\nGolang으로 연결하기 처음 Golang으로 연결하면서 여러 가지 정보들을 확인해 봤지만 Golang 버전에 따라서 Mongo Driver 들에 따라서 다양한 글들과 방법들이 나오지만 이런저런 오류들이 발생하면서 오히려 헷갈리는 상황들이 존재한다.\n이 문서에는 Golang 버전의 MongoDB Official 격이라고 판단되는 mongo-go-driver를 기준으로 한다.\nimport 구성 아래의 코드는 mongodb driver의 go 라이브러리를 import 하는 것이다. 두 가지 방법 중에 무엇을 사용해도 상관없지만 코드 구성 후에 자동 import 처리되는 것을 확인해 보니 go.mongodb.org  로 사용되기 때문에 이를 기준으로 했다.\n import 구성  1... 2import ( 3 ... 4 // 다른 소스들은 아래와 같이 처리하는 것도 많다. 5 \u0026#34;github.com/mongodb/mongo-go-driver/bson\u0026#34; 6 \u0026#34;github.com/mongodb/mongo-go-driver/bson/primitive\u0026#34; 7 \u0026#34;github.com/mongodb/mongo-go-driver/mongo\u0026#34; 8 \u0026#34;github.com/mongodb/mongo-go-driver/mongo/options\u0026#34; 9 ... 10 // 실제 코드는 CDN 격인 go.mongodb.org를 사용해서 처리했다. 11 \u0026#34;go.mongodb.org/mongo-driver/bson\u0026#34; 12 \u0026#34;go.mongodb.org/mongo-driver/bson/primitive\u0026#34; 13 \u0026#34;go.mongodb.org/mongo-driver/mongo\u0026#34; 14 \u0026#34;go.mongodb.org/mongo-driver/mongo/options\u0026#34; 15) 16...   클라이언트 연결과 검증 코드 구동 중인 mongodb가 authentication mode로 동작하고 있고, root 사용자만 만들어 놓은 상태기 때문에 이를 아래의 코드를 통해서 연결과 검증을 하면 된다.\n mongodb 연결과 검증  1... 2// timeout 기반의 Context 생성 3ctx, _ := context.WithTimeout(context.Background(), conf.Timeout) 4 5// Authetication 처리를 위한 Client Option 구성 (docker-compose.yml에 구성한 port 기준) 6clientOptions := options.Client().ApplyURI(\u0026#34;mongodb://localhost:27017) 7.SetAuth(options.Credential{ 8AuthSource: \u0026#34;\u0026#34;, // 지금은 필요없음 9Username: \u0026#34;docker-compose.yml에 지정한 사용자\u0026#34;, 10Password: \u0026#34;docker-compose.yml에 지정한 사용자 비밀번호\u0026#34;, 11 }) 12 13// mongodb 연결 14client, err := mongo.Connect(ctx, clientOptions) 15if err != nil { 16 return nil, err 17} 18 19// 연결 검증 20err = client.Ping(context.Background(), nil) 21if err != nil { 22 return nil, err 23} 24...   클라이언트 옵션에 더 많은 구성들이 있지만 이 부분들은 mongodb 매뉴얼등을 검토해 보면서 적용하면 된다.\n발생했던 문제점들 ApplyURI에 \u0026ldquo;mongodb://ID:PW@localhost:27017\u0026rdquo; 방식으로 구성할 때 오류  un-escaped character @ in user info 오류\n 위의 같은 오류 메시지는 ID나 PW에 @ 문자가 존재하는 경우에 직접 전달되면 발생하게 된다. 이를 해결하기 위해서는 \u0026quot;net/url\u0026quot; 패키지를 import 하고 아래와 같이 escape 처리를 해 줘야 한다.\n 특수문자 escape 처리  1... 2import ( 3 ... 4 \u0026#34;net/url\u0026#34; 5 ... 6) 7... 8// getConnectionURI - Returns the connection URI from the configuration 9func getConnectionURI(conf *Config) string { 10 return \u0026#34;mongodb://\u0026#34; + url.QueryEscape(conf.UserName) + \u0026#34;:\u0026#34; + url.QueryEscape(conf.Password) + \u0026#34;@\u0026#34; + conf.Host + \u0026#34;:\u0026#34; + conf.Port + \u0026#34;/\u0026#34; + conf.DatabaseName 11} 12...   url.QueryEscape  함수를 이용해서 데이터에 존재하는 특수문자를 안전하게 인식될 수 있도록 변환해 주면 된다.\n데이터 처리할 때 \u0026rdquo;(Unauthorized) command insert requires authentication\u0026rdquo; 오류 위에 언급했던 Authentication Mode로 구동되고 있는 mongodb에 인증을 처리하지 않고 Connection을 연결한 후 실제 데이터를 처리할 때 인증되지 않은 사용자로 인해서 발생하는 오류다. 이 경우는 위의 코드에서 보여진 것과 같이 인증을 한 Connection을 사용하면 오류가 해결된다.\n Authentication 처리를 구성한 Client Option 사용한 연결  처리가 필요하다.\n 연결할 때 Authentication mechanism SCRAM-SHA-1 오류 이 오류는 mongodb의 인증 방식에 대한 문제로 위에서 보여준 연결 문자열을 사용해서 처리할 떄 발생하는 오류로 인증 방식이 맞지 않아서 발생하게 된다. 이 부분에 대해서는 MongoDB Manual - Authentication Mechanisms를 참고하면 된다.\n제공되는 Authentication Mechanism은 다음과 같다.\n SCRAM X.509 Certificate Authentication LDAP Proxy Authentication (Enterprise) Kerberos Authentication (Enterprise)  표준 URI Connection Schema는 아래와 같다.\n mongodb://[username:password@]host1[:port1][\u0026hellip;hostN[:portN]][/[database][?options]]\n 위에서 보이는 것과 같이 여러 개의 host 연결 지정이 가능하고, 사용할 데이터베이스와 연결에 사용할 옵션들 지정이 가능하다.\n옵션을 통해서 Authentication Mechanism을 지정할 수 있다. 자세한 내용은 Connection Options을 참고한다.\n Connection String을 기준으로 각종 옵션을 적용해서 처리하는 것도 방법이지만 여러 가지 설정을 Configuration으로 처리하고 운영하기에는 Authenticated Client 를 사용하는 방식이 더 효율적인 것으로 판단된다.\n 참고 문서  MongoDB Physical 데이터 저장 구조 MongDB - Document MongoDB 기초 - CRUD 명령어 SQL vs NoSQL (MySQL vs. MongoDB)  "
},
{
	"uri": "http://ccambo.github.io/FunnyLab/Blogging/how-to-deploy-api-server-to-heroku/",
	"title": "OGP API 서버 Heroku에 배포하기",
	"tags": ["API Server", "Heroku", "Open Graph", "OGP"],
	"description": "",
	"content": " 이 문서는 블로그에서 외부 게시글에 대한 미리보기를 작성하면서 Open Graph를 적용하는 방법을 정리한 것입니다. Hugo나 Hexo를 기준으로 적용하는데 필요한 OGP 처리용 API Server를 구성하는 내용이므로 OGP에 대한 상세한 내용은 아래의 참고 자료를 활용하시기 바랍니다. 기본적인 개발 환경은 이미 활용하는 것으로 가정하고 git / vscode / macbook을 기준으로 설명합니다\n OGP란? 오픈그래프 (Open Graph)는 HTML 메타 태그의 종류 중의 하나로 사용성에 약간의 차이를 가진다. SNS에서 그 개념이 시작되었는데, SNS에 링크를 걸어 놓으면 이 링크가 어떤 데이터를 가지고 있는지를 알 수 있는 방법이 없기 때문에 링크에 대한 미리보기로써 이미지, 설명, 제목등을 나타내기 위한 태그들이다.\n오픈그래프에 대해서는 The Open Graph Protocol 사이트를 참고하면 된다.\n오픈 그래프의 기본적인 태그들을 다음과 같다.\n기본 태그들   Tag Description     og:title 사이트의 제목 태그   og:type 사이트의 종류 스타일 태그 (ex. website, video, movie, \u0026hellip;)   og:image 사이트의 대표 이미지 태그   og:url 사이트의 대표 URL 태그    옵션으로 적용할 수 있는 태그들을 다음과 같다.\n옵션 태그들   Tag Description     og:audio 사이트의 포함되는 Audio 파일 태그   og:description 사이트의 설명 태그   og:determiner 사이트의 구분자 태그   og:locale 사이트의 언어 태그 (기본 값은 en_US, 한글은 ko_KR, \u0026hellip;)   og:locale:alternate 사이트의 다국어일 경우 대체 언어 태그   og:site_name 사이트의 세부 카테고리 의미 태그   og:video 사이트의 포함되는 Video 파일 태그    추가적으로 객체들 (Image, Audio, Video, \u0026hellip;)에 대한 구조 속성 태그들은 다음과 같다.\n객체 구조 태그들   Tag Description     og:object 또는 og:object:url 객체의 경로 (eg. Image, Audio, Video, \u0026hellip;) 태그   og:object:secure_url SSL/TLS(HTTPS) 경로 태그   og:object:type 객체 유형 태그 (eg. image/jpeg, application/x-shockwave-flash, audio/mpeg, \u0026hellip;)   og:object:width 객체 너비 태그   og:object:height 객체 높이 태그   og:object:alt 객체 설명 태그    OGP를 위한 API 구성하기 API 구성의 목적은 링크 URL이 지정되면 해당 URL의 HTML 내용 중에서 Head 태그 내의 Open Graph 정보를 추출해서 JSON 형식으로 반환하는 것이다. 이 정보를 기준으로 각 블로그 툴 (SSG : Static Site Generator)에서는 SNS처럼 게시글 링크를 표시하는 Preview Box를 구성하게 된다.\n가장 먼저할 것은 API를 구동해서 사용할 수 있는 무료로 지원되는 호스팅 서버를 결정하는 것이다. 처음에는 firebase를 검토해서 구현을 했지만 외부 URL을 긁어와야 하는 부분에서 Firebase는 외부로 연계되는 경우 무료 계정에서는 사용할 수 없는 제한이 존재하기 때문에 Heroku 를 이용하는 것으로 결정했다.\nAWS, Azure, GCP 등의 외부에서 호출해서 결과를 받을 수 있는 호스팅을 이미 할 수 있는 계정이 존재한다면 그것을 이용해도 된다.\n 가장 먼저 시작해야 할 것이 Heroku의 계정을 만드는 것이다.\nHeroku 계정설정 Heroku는 Git 기반으로 운영되기 때문에 당연히 로컬 PC에 git가 설치되어 있어야 한다.\n Heroku 사이트에 계정 생성 무료 계정은 아래와 같은 제한이 있다\n 30분간 접속이 없으면 사이트를 Sleep 시킨다. (요청이 들어와서 재 구동되는데 10~30초 정도 걸림) 계정 당 한달에 550시간만 사용 가능하다. 계정에 사이트가 여러 개인 경우는 합산 시간을 기준으로 한다.  [ 회원가입 ]  아래와 같이 정보를 등록하고 \u0026ldquo;Create Free Account\u0026rdquo; 버튼을 눌러서 가입하면 된다. 기본적으로 사용하는 언어는 본인이 주로 사용하는 언어를 선택하면 된다.\n[ 회원정보설정 ]  Heroku CLI 설치 Heroku는 Git기반이기 때문에 로컬 PC에서 작업하고 Heroku로 Push해서 처리하면 된다. 따라서 Heroku 연동을 위한 CLI (Command Line Interface)를 설치해야 한다.\n heroku 사이트에 로그인한 후에 다운로드로 이동해서 플랫폼에 맞는 것을 다운로드해서 설치 (아래 그림의 빨간색 처리 부분을 통해서 이동) [ CLI 설치 페이지 ] \n 설치 페이지의 내용대로 설치\n  Heroku CLI 주요 명령 정리\nHeroku CLI Commands   Command Description     heroku login 로그인   heroku logout 로그인은 재부팅을 하더라도 지속성을 가지므로 로그아웃을 원할 경우는 이 명령을 수행해야 한다.   heroku create [프로젝트 이름] Git 저장소와 연결될 폴더에서 새로운 프로젝트를 생성하는 명령으로 \u0026ldquo;프로젝트 이름\u0026rdquo;을 주지 않으면 랜덤으로 생성되고 URL과 연계되므로 프로젝트 이름을 지정하는 것이 좋다.   heroku remote -v 생성된 프로젝트의 원격 저장소 정보를 보는 것으로 로컬 저장소는 \u0026ldquo;heroku\u0026rdquo; 라는 이름으로 생성된다.   heroku git:remote -a 프로젝트 이름 위의 create가 새로운 프로젝트를 생성하는 것이라면 이미 존재하는 프로젝트에 연결하는 것은 이 명령으로 프로젝트를 지정하면 된다.   heroku config:set [키=값] 프로젝트와 연계되는 저장소에 환경 변수를 설정한다.   heroku config 프로젝트와 연계되는 저장소에 설정되어 있는 환경 변수들을 출력한다.   heroku config:get [키] 프로젝트와 연계되는 저장소에 설정되어 있는 환경 변수들 중에서 지정한 키의 값을 출력한다.   heroku config:unset [키] 프로젝트와 연계되는 저장소에 설정되어 있는 환경 변수들 중에서 지정한 키의 환경 변수를 삭제한다.   heroku logs [\u0026ndash;tail] Heroku에서 구동된 서버의 Console log를 출력한다. 테스트 중에 오류나 디버그 용도로 사용한다.    Heroku의 프로젝트 이름은 저장소 명칭일뿐만 아니라 향후 외부로 노출될 App 식별명이기도 하므로 반드시 잘 생각해보고 생성해야 한다. 외부에서 접속하는 주소는 [프로젝트 명].herokuapp.com 으로 생성된다.\n OGP 처리를 위한 API 구성 (로컬 PC) 아주 간단한 OGP API Server를 구성할 것이기 때문에 node + express + ogp_parser 조합  으로 아래와 같이 소스를 구성한다.\n 기본 설치 작업  $ npm init # package.json 구성 $ npm install express --save # node express 설치 $ npm install ogp-parser --save # ogp-parser 설치   위와 같이 기본적인 설치를 한 후에 package.json 파일을 열고 나머지 부분을 구성하도록 한다.\n 전체 package.json 파일  1{ 2 \u0026#34;name\u0026#34;: \u0026#34;ogp-to-json\u0026#34;, 3 \u0026#34;version\u0026#34;: \u0026#34;0.0.1\u0026#34;, 4 \u0026#34;description\u0026#34;: \u0026#34;지정한 URL 정보를 기준으로 Open Graph 정보를 추출해서 JSON 형식으로 반환합니다.\u0026#34;, 5 \u0026#34;main\u0026#34;: \u0026#34;index.js\u0026#34;, 6 \u0026#34;scripts\u0026#34;: { 7 \u0026#34;start\u0026#34;: \u0026#34;node ./\u0026#34; 8 }, 9 \u0026#34;keywords\u0026#34;: [ 10 \u0026#34;Open Graph\u0026#34;, 11 \u0026#34;ogp\u0026#34;, 12 \u0026#34;Heroku\u0026#34; 13 ], 14 \u0026#34;author\u0026#34;: \u0026#34;morris chang\u0026#34;, 15 \u0026#34;license\u0026#34;: \u0026#34;MIT\u0026#34;, 16 \u0026#34;engines\u0026#34;: { 17 \u0026#34;node\u0026#34;: \u0026#34;v13.2.0\u0026#34;, 18 \u0026#34;npm\u0026#34;: \u0026#34;6.13.2\u0026#34; 19 }, 20 \u0026#34;dependencies\u0026#34;: { 21 \u0026#34;express\u0026#34;: \u0026#34;^4.17.1\u0026#34;, 22 \u0026#34;ogp-parser\u0026#34;: \u0026#34;^0.4.4\u0026#34; 23 } 24}   위의 package.json 파일의 내용 중에 아래 서술한 부분은 로컬테스트와 Heroku에서 실행될 정보를 구성한 것이다.\n scripts : 로컬 및 Heroku에서 npm을 통해서 실행할 명령이다. (eg. npm start) main : scripts/start에 \u0026ldquo;node ./\u0026rdquo; 으로 지정하면 main에 설정된 파일을 처리한다. main 지정이 없을 경우는 scripts/start를 \u0026ldquo;node ./index.js\u0026rdquo;로 해 줘야 한다. engines : Heroku에서 실행될 node와 npm에 대한 버전 정보를 지정한 것이다. (별다른 문제가 없다면 로컬에 설치된 버전을 그대로 이용하면 된다.)  버전 정보를 모를 경우는 node -v, npm -v 명령으로 현재 설치된 버전 확인이 가능하다.   index.js 파일에 아래와 같이 코드를 구성한다.\n index.js  1const express = require(\u0026#39;express\u0026#39;); 2 3const app = express(); 4const PORT = process.env.PORT || 80 5 6// 호출 url : opg-to-json.herokuapp.com/ogp?url=..... 7app.get(\u0026#34;/ogp\u0026#34;, (req, res) =\u0026gt; { 8 const parser = require(\u0026#39;ogp-parser\u0026#39;); 9 const params = req.query; 10 const cacheControl = \u0026#39;public, max-age=31557600, s-maxage=31557600\u0026#39;; // cache 1year 11 12 if (!params.hasOwnProperty(\u0026#39;url\u0026#39;)) { 13 console.error(\u0026#39;Error getting ogp data: Please provide url parameter\u0026#39;); 14 return res.json({error: \u0026#39;Error getting ogp data: Please provide url parameter\u0026#39;}); 15 } 16 17 return parser(encodeURI(params[\u0026#39;url\u0026#39;]), false) 18 .then((data) =\u0026gt; { 19 console.log(data); 20 console.log(params[\u0026#39;url\u0026#39;]); 21 if (!data.hasOwnProperty(\u0026#39;title\u0026#39;)) { 22 console.error(\u0026#39;Error getting ogp data: no ogpData returned\u0026#39;); 23 return res.json({error: \u0026#39;No OGP data returned from given url\u0026#39;}); 24 } 25 let ogpData = {}; 26 ogpData[\u0026#39;siteName\u0026#39;] = data.title; 27 for(let prop in data.ogp) { 28 if (/^og:/g.test(prop)) { 29 ogpData[prop.split(\u0026#39;:\u0026#39;)[1]] = data.ogp[prop][0]; 30 } 31 } 32 return res.set(\u0026#39;Cache-Control\u0026#39;, cacheControl).json(ogpData); 33 }) 34 .catch((err) =\u0026gt; { 35 console.error(\u0026#39;Error getting ogp data: \u0026#39; + err); 36 return res.json({error: err}); 37 }); 38}); 39 40app.listen(PORT, err =\u0026gt; { 41 if (err) throw err; 42 console.log(\u0026#34;%c Server running\u0026#34;, \u0026#34;color:green\u0026#34;); 43});   위의 코드는 아래와 같이 처리를 위한 정보를 구성하고 있다.\n line 3 : express 서버 인스턴스 생성 line 4 : express가 리스닝할 포트를 지정한다. heroku에서는 환경변수에서 PORT를 할당받는 방식을 선택해야 한다. line 7 : \u0026ldquo;ogp\u0026rdquo; 패스로 Request가 오면 처리를 수행하는 핸들러를 구성한다. line 9 : Request로 전달된 Parameter들을 변수에 할당한다. line 12 : Request의 Query String으로 \u0026ldquo;url\u0026rdquo;이 전달되었는지를 검사한다. line 13-14 : \u0026ldquo;url\u0026rdquo; 이 없다면 오류 처리 line 17 : \u0026ldquo;ogp-parser\u0026rdquo;를 이용해서 지정된 \u0026ldquo;Url\u0026rdquo;의 데이터를 읽어서 OGP 데이터 추출 line 18-33 : OGP 데이터의 존재 여부 검증 및 캐시 데이터 및 반환 데이터 처리와 오류 발생시 처리 line 40-43 : express가 지정한 포트의 요청을 받을 수 있도록 구동  이제 로컬에서 먼저 실행을 해서 정상적인 OGP json이 반환되고 있는지를 확인해 보면 된다.\n shell에서 실행 검증  $ npm start $ curl \u0026#34;http://localhost/ogp?url=http://ccambo.gitlab.io/2017/07/09/VSCODE-VSCode%EC%97%90-Git-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/\u0026#34;   정상적으로 JSON 포맷의 OGP 데이터가 출력되는 것을 확인했으면 이제 Heroku에 배포를 하면 된다.\nHeroku에 배포하기 Heroku가 git 기반으로 동작한다고 이야기를 했으므로 git 저장소 생성(프로젝트 생성)을 진행한다.\n shell에서 git구성 및 Heroku 프로젝트 생성 (로컬 프로젝트 폴더)  $ git init # 프로젝트 폴더에 git 저장소 구성 $ heroku login # heroku에 로그인 id/pw를 입력해서 처리 (이미 되어있는 경우는 Skip) $ heroku create [프로젝트 이름] # heroku에 프로젝트(저장소) 생성 Creating ⬢ [프로젝트 이름]... done https://[프로젝트 이름].herokuapp.com/ | https://git.heroku.com/[프로젝트 이름].git # heroku 서버 접속 URL 및 Git 저장소 URL 표시   생성이 끝나면 Heroku 프로젝트 접속용 URL과 Git 저장소 URL이 출력된다. 이를 이용해서 로컬 저장소를 Heroku 저장소와 연결한다.\n shell에서 원격 저장소 연결 (로컬 프로젝트 폴더)  $ git remote add heroku [프로젝트 Git 저장소 URL] # 위에서 출력된 GIt 저장소 URL 사용   만일 해당 출력을 확인하지 못해서 git 저장소 URL을 모를 경우는 Heroku에 접속해서 Dashboard로 이동한 후에 생성한 프로젝트의 \u0026ldquo;Settings\u0026rdquo; 정보를 통해서 확인할 수 있다.\n[ Heroku Dashboard 페이지에서 프로젝트 선택 ]  이제 저장소 연결이 완성되었으므로 로컬의 소스를 Heroku에 올리면 된다. (일반적인 git 처리와 동일하다)\n shell에서 Heroku로 소스 올리기  $ git add . # 변경된 파일들 stage 처리 $ git commit -m \u0026#34;커밋 메시지\u0026#34; # stage를 로컬 저장소에 commit $ git push heroku master # 로컬 저장소(heroku)의 commit 내용을 Heroku (master)로 push (upload) $ heroku open # 저장소에 올려진 소스를 기반으로 Heroku Application 구동   별다른 오류가 없었다면 heroku open  로 실행된 브라우저는 당연히 Cannot GET / 라는 오류가 발생하는 것이 정상이다.\n위에서 구동한 소스가 /ogp 패스에 대해서만 동작하도록 구성했기 때문으로 정상적으로 구동된 것을 확인할 수 있다.\n정상적인 결과를 확인하기 위해서는 열려있는 브라우저 주소 창에 다음과 같이 입력하면 된다.\n 브라우저 주소창에 URL 설정  \u0026#34;http://[프로젝트 이름].herokuapp.com/ogp?url=http://ccambo.gitlab.io/2017/07/09/VSCODE-VSCode%EC%97%90-Git-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/\u0026#34;   또는 터미널에서 아래와 같이 curl을 이용해서도 확인 가능하다.\n shell에서 URL 설정  $ curl \u0026#34;http://[프로젝트 이름].herokuapp.com/ogp?url=http://ccambo.gitlab.io/2017/07/09/VSCODE-VSCode%EC%97%90-Git-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/\u0026#34;   결론 위와 같이 처음으로 단순한 API Server를 로컬에서 구성해서 Git 기반의 무료 어플리케이션 호스팅인 Heroku에 올려서 처리하는 것을 확인해 보았다.\n 무료 계정을 일부 제한이 존재한다. Git 기반으로 통합되어 있다. Heroku CLI를 기준으로 Heroku에 각종 처리를 수행한다.  참고자료  Open Graph How to Use Open Graph Tags Heroku(무료 호스팅 서버) 설치 및 사용기 express/node.js 를 이용해 서버를 만들어 heroku에 올리는 방법  "
},
{
	"uri": "http://ccambo.github.io/Cloud/",
	"title": "Cloud",
	"tags": [],
	"description": "",
	"content": " Cloud 이 문서에서는 Cloud에 필요한 정보들을 정리하고 있습니다.\n Concepts   Concepts Cloud와 연계되는 개념들을 정리합니다. Edge Computing Edge Computing에 대한 내용을 정리합니다.  Docker  이 페이지는 Docker에 대한 관련된 정보들을 정리합니다.\n Kubernetes  이 페이지는 Kubernetes에 관련된 정보를 정리합니다.\n "
},
{
	"uri": "http://ccambo.github.io/Dev/Nuxt/",
	"title": "Nuxt",
	"tags": [],
	"description": "",
	"content": " Nuxt Nuxt에 대한 소개 및 사용하는데 필요한 정보들을 정리합니다.\n Nuxt 활용 팁들 정리  Nuxt 기반의 개발에 유용하게 사용할 수 있는 팁들과 문제 해결방법들을 정리합니다.\n Nuxt에 AXIOS 적용하기  Axios는 Nuxt 커뮤니티에서 공식으로 지원하는 모듈로 이에 대한 기본적인 사용법과 적용 방법을 정리하고 있습니다.\n "
},
{
	"uri": "http://ccambo.github.io/Git/Submdule/",
	"title": "Submodule",
	"tags": [],
	"description": "",
	"content": " Submodule 이 문서에서는 Git의 Submodule에 관련된 정보들을 정리하고 있습니다.\n What is the submodule  Git의 Submodule에 관련된 내용을 정리합니다.\n "
},
{
	"uri": "http://ccambo.github.io/Dev/",
	"title": "Dev",
	"tags": [],
	"description": "",
	"content": " Developments 이 문서에서는 개발에 필요한 정보들을 정리하고 있습니다.\n Vue  Vue Vue에 대한 소개 및 사용하는데 필요한 정보들을 정리합니다. Vue 키 포인트 소개 프로젝트에 Vue를 도입한 결정적인 이유 Vue 기본 개념 Vue.js에 대한 간략한 기본 개념 소개 Vuetify v2.x 업그레이드 Vue 및 Vuetify와 관련된 프로젝트를 v2.x 버전으로 업그레이드해서 작업할 때 발생하는 문제점들을 정리한다. Vuex의 Store란 무엇일까? Vue 개발에서 상태를 관리해 주는 기능을 제공해 주는 것이 Vuex이고 어플리케이션의 모든 컴포넌트들에 대한 중앙 집중식 저장소의 역할 및 관리 를 담당한다.\n Nuxt   Nuxt Nuxt에 대한 소개 및 사용하는데 필요한 정보들을 정리합니다. Nuxt 활용 팁들 정리 Nuxt 기반의 개발에 유용하게 사용할 수 있는 팁들과 문제 해결방법들을 정리합니다. Nuxt에 AXIOS 적용하기 Axios는 Nuxt 커뮤니티에서 공식으로 지원하는 모듈로 이에 대한 기본적인 사용법과 적용 방법을 정리하고 있습니다.  Go   Golang Golang에 대한 소개 및 사용하는데 필요한 정보들을 정리합니다. Golang으로 MongoDB 연결해 보기 MongoDB를 Docker Compose 로 구동한 후에 Go Package를 이용해서 MongoDB에 접속하는 방법을 정리하고 있습니다.  Web   Web 이 문서에서는 웹 구성에 필요한 정보들을 정리하고 있습니다. NPM vs YARN npm과 yarn에 대한 비교  "
},
{
	"uri": "http://ccambo.github.io/Dev/Go/",
	"title": "Go",
	"tags": [],
	"description": "",
	"content": " Golang Golang에 대한 소개 및 사용하는데 필요한 정보들을 정리합니다.\n Golang으로 MongoDB 연결해 보기  MongoDB를 Docker Compose 로 구동한 후에 Go Package를 이용해서 MongoDB에 접속하는 방법을 정리하고 있습니다.\n "
},
{
	"uri": "http://ccambo.github.io/Dev/Vue/How-to-solving-the-problems-in-vuetify-upgrade-to-v2.x/",
	"title": "Vuetify v2.x 업그레이드",
	"tags": ["Vue", "Vuetify", "Stylus", "sass", "v2.x", "Migration", "오류"],
	"description": "Vue 및 Vuetify와 관련된 프로젝트를 v2.x 버전으로 업그레이드해서 작업할 때 발생하는 문제점들을 정리한다.",
	"content": " Vuetify v1.x에서 v2.x로 Upgrade에서 발생하는 문제점들 Vuetify가 v2.x로 버전이 변경되면서 기존 버전을 사용하던 소스들에서 여러 가지 문제가 발생한다. 그 중에 실제로 작업을 진행한 것들을 정리하고 있다. 만일 이 정리외의 사항들까지 처리해야 하는 경우라면 Release and Migration guide 문서를 참고하면 된다.\nStylus to Sass 이 문제는 Vutify v1.x 버전에서는 Stylus를 사용했지만 v2.x 버전 부터는 sass를 사용하기 때문에 소스 상에서 참고하던 stylus 파일이 존재하지 않고 sass-loader 들을 webpack이 필요로 하면서 발생하게 된다.\nimport해서 사용하는 소스 경로 변경\n Vue v1.x 사용 예 (src/plugins/vuetify.ts)  1... 2 import \u0026#39;vuetify/src/stylus/app.styl\u0026#39;; 3...   위의 2번째 라인에서 사용한 stylus/* 소스들이 제거되었기 때문이므로 이를 아래와 같이 신규 제공되는 것으로 변경하면 된다.\n Vue v2.x 사용 예 (src/plugins/vuetify.ts)  1... 2 import \u0026#39;vuetify/dist/vuetify.min.css\u0026#39;; 3...   Webpack에서 사용할 sass, sass-loader 설치\n yarn 처리  # stylus 제거 $ yarn remove stylus stylus-loader # sass 설치 $ yarn add sass sass-loader   [Vue warn]: Error in beforeCreate hook: \u0026ldquo;Error: Vuetify is not properly initialized 이 문제는 Vuetify v1.x 버전의 vuetify 초기화 방식이 v2.x 버전에서는 제대로 초기화되지 않기 때문에 발생한다.\nv1.x 버전에서는 아래와 같이 main.ts 파일과 /plugins/vuetify.ts 파일을 사용해서 초기화하고 Vue에 등록해서 사용한다.\n Vue v1.x 사용 예   1// ./plugins/vuetify.ts 2import Vue from \u0026#39;vue\u0026#39;; 3import Vuetify from \u0026#39;vuetify/lib\u0026#39;; // vuetify import 4import \u0026#39;vuetify/src/stylus/app.styl\u0026#39;; 5 6Vue.use(Vuetify, { // Vue에 등록 (with options) 7 iconfont: \u0026#39;md\u0026#39;, 8}); 9 10// main.ts 11import Vue from \u0026#39;vue\u0026#39;; 12 13import App from \u0026#39;./App.vue\u0026#39;; 14import \u0026#39;./plugins/vuetify\u0026#39;; // Vuetify plugin import (이미 등록됨) 15import router from \u0026#39;./router\u0026#39;; 16import store from \u0026#39;./store/index\u0026#39;; 17 18Vue.config.productionTip = false; 19 20new Vue({ 21 router, 22 store, 23 render: (h) =\u0026gt; h(App), 24}).$mount(\u0026#39;#app\u0026#39;);   v2.x 버전에서는 위와 같이 처리하면 컴파일등의 문제는 없지만 실행 시점에 초기화되지 않는 문제가 발생하므로 아래와 같이 초기화 방법을 변경해 주어야 한다.\n Vue v2.x 사용 예   1// ./plugins/vuetify.ts 2import Vue from \u0026#39;vue\u0026#39;; 3import \u0026#39;vuetify/dist/vuetify.min.css\u0026#39;; 4import Vuetify from \u0026#39;vuetify/lib\u0026#39;; // Vuetify import 5 6import colors from \u0026#39;vuetify/lib/util/colors\u0026#39;; 7 8Vue.use(Vuetify); // Vue에 등록 (without options) 9 10export default new Vuetify({ // option을 지정한 Vuetify instance 생성해서 export 11 icons: { 12 iconfont: \u0026#39;md\u0026#39;, // \u0026#39;mdi\u0026#39; || \u0026#39;mdiSvg\u0026#39; || \u0026#39;md\u0026#39; || \u0026#39;fa\u0026#39; || \u0026#39;fa4\u0026#39; 13 }, 14 theme: { 15 dark: false, 16 }, 17 themes: { 18 light: { 19 primary: \u0026#39;#4682b4\u0026#39;, 20 secondary: \u0026#39;#b0bec5\u0026#39;, 21 accent: \u0026#39;#8c9eff\u0026#39;, 22 error: \u0026#39;#b71c1c\u0026#39;, 23 }, 24 dark: { 25 primary: colors.blue.lighten3, 26 }, 27 }, 28}); 29 30// main.ts 31import Vue from \u0026#39;vue\u0026#39;; 32 33import App from \u0026#39;./App.vue\u0026#39;; 34import vuetify from \u0026#39;./plugins/vuetify\u0026#39;; // vuetify plugin import 35import router from \u0026#39;./router\u0026#39;; 36import store from \u0026#39;./store/index\u0026#39;; 37 38Vue.config.productionTip = false; 39 40new Vue({ 41 vuetify, // Vue Instance에 등록 42 router, 43 store, 44 render: (h) =\u0026gt; h(App), 45}).$mount(\u0026#39;#app\u0026#39;);   [Vuetify] [BREAKING] \u0026lsquo;app\u0026rsquo; has been removed, use \u0026lsquo;\u0026lt;v-app-bar app\u0026gt;\u0026rsquo; instead. 이 문제는 Vuetify v2.x 버전에서 기존의 app가 제거되고 \u0026lt;v-app-bar app\u0026gt;로 변경되었기 떄문에 발생한다.\n Vue v1.x 사용 예  1... 2 \u0026lt;v-toolbar app ...\u0026gt; 3 ... 4 \u0026lt;/v-toolbar\u0026gt; 5...   위의 2번째 라인에서 사용한 \u0026lt;v-toolbar app ...\u0026gt; 태그가 제거되었기 때문이므로 이를 아래와 같이 신규 제공되는 것으로 변경하면 된다.\n Vue v2.x 사용 예  1... 2 \u0026lt;v-app-bar app ...\u0026gt; 3 ... 4 \u0026lt;/v-app-bar\u0026gt; 5...   [Vuetify] [BREAKING] \u0026lsquo;clipped-left\u0026rsquo; has been removed, use \u0026lsquo;\u0026lt;v-app-bar clipped-left\u0026gt;\u0026rsquo; instead 이 문제는 Vuetify v2.x 버전에서 기존의 \u0026lt;v-toolbar\u0026gt;가 제거되고 \u0026lt;v-app-bar app\u0026gt;로 변경되었기 떄문에 발생한다.\n Vue v1.x 사용 예  1... 2 \u0026lt;v-toolbar :clipped-left= ...\u0026gt; 3 ... 4 \u0026lt;/v-toolbar\u0026gt; 5...   위의 2번째 라인에서 사용한 \u0026lt;v-toolbar\u0026gt; 태그가 제거되었기 때문이므로 이를 아래와 같이 신규 제공되는 것으로 변경하면 된다.\n Vue v2.x 사용 예  1... 2 \u0026lt;v-app-bar :clipped-left= ...\u0026gt; 3 ... 4 \u0026lt;/v-app-bar\u0026gt; 5...   [Vuetify] [BREAKING] \u0026lsquo;flat\u0026rsquo; has been removed, use \u0026lsquo;text\u0026rsquo; instead. 이 문제는 Vuetify v2.x 버전에서 \u0026lt;v-btn\u0026gt; 태그에 사용했던 flat 속성이 제거되고 text 속성을 사용하는 것으로 변경되었기 떄문에 발생한다.\n Vue v1.x 사용 예  1... 2\u0026lt;v-btn v-if=\u0026#34;isAuthenticated === false\u0026#34; class=\u0026#34;hidden-xs-only\u0026#34; to=\u0026#34;/login\u0026#34; flat\u0026gt;Login\u0026lt;/v-btn\u0026gt; 3...   위의 2번째 라인에서 사용한 flat 속성이 제거되었기 때문이므로 이를 아래와 같이 신규 제공되는 것으로 변경하면 된다.\n Vue v2.x 사용 예  1... 2\u0026lt;v-btn v-if=\u0026#34;isAuthenticated === false\u0026#34; class=\u0026#34;hidden-xs-only\u0026#34; to=\u0026#34;/login\u0026#34; text\u0026gt;Login\u0026lt;/v-btn\u0026gt; 3...   \u0026lt;v-btn\u0026gt; 태그에서 변경된 내용은 다음과 같다.\n flat -\u0026gt; text round -\u0026gt; rounded explicit margin removed  [Vuetify] [BREAKING] \u0026lsquo;outline\u0026rsquo; has been removed, use \u0026lsquo;outlined\u0026rsquo; instead 이 문제는 Vuetify v2.x 버전에서 \u0026lt;v-btn\u0026gt;, \u0026lt;v-autocomplete\u0026gt;, \u0026lt;v-alert\u0026gt;, ... 태그에 사용했던 outline 속성이 제거되고 outlined 속성을 사용하는 것으로 변경되었기 떄문에 발생한다.\n Vue v1.x 사용 예  1... 2\u0026lt;v-btn outline\u0026gt;Login\u0026lt;/v-btn\u0026gt; 3...   위의 2번째 라인에서 사용한 \u0026lt;v-btn outline\u0026gt; 속성의 이름이 변경되었기 때문이므로 이를 아래와 같이 신규 제공되는 것으로 변경하면 된다.\n Vue v2.x 사용 예  1... 2\u0026lt;v-btn outlined\u0026gt;Login\u0026lt;/v-btn\u0026gt; 3...   이 변경에 영향을 받는 태그들은 다음과 같다.\n v-text-field v-select v-textarea v-autocomplete v-combobox v-btn v-alert  참고 자료  Vuetify v2.x Releases and Migrations Vuetify Upgrade 1.x to 2.x Vue-Vuetify is not properly initialized Vuetify - theme Customization Vuetify v2.x Upgrade guide  "
},
{
	"uri": "http://ccambo.github.io/FunnyLab/",
	"title": "FunnyLab",
	"tags": [],
	"description": "",
	"content": " Funny Lab 엉뚱하고 재미있는 상상들을 정리하고 있습니다.\n Blogging  Blogging 이 문서에서는 Hugo 및 Hexo 블로그 구성에 필요한 정보들을 정리하고 있습니다. 댓글 시스템 utterances로 변경 기존 Disqus 댓글 시스템의 문제점으로 Github연동형 댓글 시스템인 utternaces로 변경한 내용을 정리합니다. OGP API 서버 Heroku에 배포하기 이 문서는 블로그에서 외부 게시글에 대한 미리보기를 작성하면서 Open Graph를 적용하는 방법을 정리한 것입니다. Hugo나 Hexo를 기준으로 적용하는데 필요한 OGP 처리용 API Server를 구성하는 내용이므로 OGP에 대한 상세한 내용은 아래의 참고 자료를 활용하시기 바랍니다.\n "
},
{
	"uri": "http://ccambo.github.io/Dev/Web/",
	"title": "Web",
	"tags": [],
	"description": "",
	"content": " Web 이 문서에서는 웹 구성에 필요한 정보들을 정리하고 있습니다.\n NPM vs YARN  npm과 yarn에 대한 비교\n "
},
{
	"uri": "http://ccambo.github.io/Dev/Nuxt/nuxt-tips/",
	"title": "Nuxt 활용 팁들 정리",
	"tags": ["Nuxt", "Vue", "Vuetify", "Tips", "Errors", "Typescript", "Module parse failed: Identifier &#39;installComponents&#39; has already been declared", "folder rename / move", "ERR_ACTION_ACCESS_UNDEFINED"],
	"description": "Nuxt 기반의 개발에 유용하게 사용할 수 있는 팁들과 문제 해결방법들을 정리합니다.",
	"content": " - 이 문서에서는 Nuxt 환경에서 활용할 수 있는 팁이나 오류 해결 방법들을 정리하고 있으며 수시로 변경될 수 있습니다.\n 개발할 때 자동으로 브라우저 실행시키기 딱히 획기적인 팁은 아니지만 터미널에서 개발서버를 구동시키고 브라우저로 확인하는 것이 기본이다 보니 브라우저를 다시 실행하는 것이 귀찮을때가 많다. 물론 한번 실행하고 안 닫으면 되겠지만\u0026hellip;\npackage.json을 사용하는 방법 package.json에 구성한 스크립트에 --open 옵션을 추가하면 된다.\n package.json - 개발서버 실행할 때 브라우저 실행하기  1... 2 scripts: { 3 \u0026#39;dev\u0026#39;: \u0026#39;nuxt-ts --open\u0026#39; // typescript가 아닌 경우는 \u0026#34;nuxt --open\u0026#34; 사용 4 ... 5 } 6...     빌드되는 동안 브라우저에 살짝 진행 과정이 표시된다. 시스템 기본 브라우저가 실행된다.  opn 모듈 사용 위의 방식이 편하지만 맥북의 경우는 크롬이 아니라 사파리가 열린다. 물론 기본 브라우저를 바꾸면 되지만 시스템 설정을 바꾸지 않고 처리하는 방법은 opn 모듈을 설치해서 사용하는 것이다.\n opn 패키지 설치  $ yarn add -D opn // 개발 의존성으로 설치   기본적인 사용방법은 아래와 같이 URL, 옵션 방식이다.\n opn 실행 방법  // 크롬 실행 opn(\u0026#39;http://ccambo.github.io\u0026#39;, {app: \u0026#39;chrome\u0026#39;}); // \u0026#39;google chrome\u0026#39;, \u0026#39;firefox\u0026#39;, ...    추가적인 정보와 옵션들은 위의 opn 링크를 참조하면 된다.\nNuxt에 적용하는 방법은 간단한다. nuxt.config.ts 파일에 opn 패키지를 import하고 nuxt의 hooks 를 이용해서 호스트의 변경이 발생하면 브라우저를 실행해 주는 방식이다.\nnuxt.config.js (javascript 환경인 경우)  nuxt.config.js - opn 패키지 적용  1const opn = require(\u0026#39;opn\u0026#39;) 2... 3export default { 4 ... 5 hooks: { 6 listen(server, { host, port }) { 7 opn(`http://${host}:${port}`, { app: [\u0026#39;google chrome\u0026#39;, \u0026#39;--incognito\u0026#39;]}); 8 } 9 } 10 ... 11}    nuxt.config.ts (Typescript 환경인 경우)  nuxt.config.ts - opn 패키지 적용  1const opn = require(\u0026#39;opn\u0026#39;) // 형식 노출이 없어서 import 문에 오류 발생하므로... 2... 3export default { 4 ... 5 hooks: { 6 listen: (_server: any, { host, port }: any) =\u0026gt; { // _server는 no-unused-var 오류를 피하는 방법 7 opn(`http://${host}:${port}`, { app: [\u0026#39;google chrome\u0026#39;, \u0026#39;--incognito\u0026#39;]}) 8 } 9 } 10 ... 11}    Module parse failed: Identifier \u0026lsquo;installComponents\u0026rsquo; has already been declared  Nuxt App run dev  $ yarn run dev # 또는 npm run dev 또는 npx run dev   위의 명령으로 개발환경으로 처리할 때는 문제가 없이 동작을 했지만 배포 테스트를 위해서 아래와 같이 빌드 명령을 수행하면 오류가 발생한다.\n Nuxt App run build/generate  $ yarn run build # 또는 npm run build 또는 npx run build   발생하는 오류는 다음과 같다.\n Module parse failed: Identifier \u0026lsquo;installComponents\u0026rsquo; has already been declared\n 오류를 해석해 보면 \u0026ldquo;installComponents\u0026rdquo;가 선언되었기 때문에 중복으로 선언되어 Moudle 파싱을 처리할 수 없다는 내용이다. 이런 문제가 발생하는 이유는 Vuetify가 두번 로드되고 있다고 생각하면 된다.\nNuxt에서는 Webpack이 내부적으로 구성되어 동작하고 Vuetify를 Module로 처리하고 있기 때문에 이런 중복에 관련된 것은 설정상의 문제 (nuxt.config.[js|ts]]) 뿐이 없다. 물론 Webpack을 커스텀하게 구성하고 있다면 다른 문제가 된다.\n여기서는 기본적인 Nuxt를 사용하고 있다는 가정하게 아래와 같이 nuxt.config.[js|ts] 파일에 중복 설정된 것을 확인해 보면 된다.\n nuxt.config.ts - Vuetify Module 설정  1... 2 /* 3** Nuxt.js Build modules 4*/ 5 buildModules: [ 6 \u0026#39;@nuxt/typescript-build\u0026#39;, 7 \u0026#39;@nuxtjs/vuetify\u0026#39;, 8 ], 9... 10 /* 11** Nuxt.js modules 12*/ 13 modules: [ 14 [ 15 \u0026#39;@nuxtjs/axios\u0026#39;, 16 { 17 debug: process.env.NODE_ENV === \u0026#39;development\u0026#39; 18 } 19 ], 20 \u0026#39;@nuxtjs/vuetify\u0026#39; 21 // \u0026#39;@nuxtjs/auth\u0026#39;, 22 // \u0026#39;nuxt-material-design-icons\u0026#39; 23 ], 24...    위의 예시와 같이 buildModules, Modules 두 곳에 @nuxtjs/vuetify가 등록되어 있는 것을 확인할 수 있다. 이런 문제가 생기는 이유는 아마도 Vuetify 버전을 Upgrade 등을 수행하면서 처리된 것이다.\n buildModules 에서 @nuxtjs/vuetify를 제거  해 주면 문제가 해결된다.\n 기본 폴더 재 정의하기 Nuxt는 기본적인 폴더 구조를 제공하고 있다. 그런데 실제 프로젝트를 진행하다 보면 이를 재 구성해서 의미론적으로 운영할 때가 많다. 예를 들면 \u0026ldquo;layout\u0026rdquo;과 \u0026ldquo;pages\u0026rdquo;를 모두 \u0026ldquo;Views\u0026rdquo;라는 폴더 밑의 서브 폴더로 통합운영하는 것 등이다.\n Nuxt 기본 폴더  ./ assets/ components/ layouts/ ... pages/ ... store/    위의 기본 폴더를 아래와 같이 기능별로 묶어서 구성할 수 있다.\n Nuxt 기본 폴더  ./ assets/ components/ ... store/ views/ layouts/ pages/    위와 같이 폴더를 재 구성하는 경우는 아래와 같이 \u0026ldquo;nuxt.config.[js|ts]\u0026rdquo; 를 변경하면 된다.\n nuxt.config.ts - 폴더 재 구성  ... dir: { layouts: \u0026#39;views/layouts\u0026#39;, pages: \u0026#39;views/pages\u0026#39; } ...    \u0026ldquo;ERR_ACTION_ACCESS_UNDEFINED\u0026rdquo; 오류 nuxt.js에서 Store의 Action을 \u0026ldquo;vuex-module-decorators\u0026rdquo; 패키지를 이용해서 사용할 때 아래와 같은 오류가 발생할 수 있다.\n Namespaces do not function. Throws \u0026ldquo;ERR_ACTION_ACCESS_UNDEFINED\u0026rdquo; when using namespaces\n vuex-module-decorators 내부에서 처리하는 과정에 발생하는 것으로 설정에 따라서 다양한 원인으로 발생할 수 있다. 다만, 그 중에 한가지는 Store Action에서 사용자 정의 Error를 반환할 떄 발생하는 것이며, 아래와 같이 Action 선언을 처리해 주면 된다.\n @/store/user.ts - 사용자 정의 오류 반환  1... 2 @Action({ rawError: true }) 3 public async signup(name: string, email: string, password: string) { 4 // TODO: password 암호화 5 let data = await $axios.$post(\u0026#39;/signup\u0026#39;, { name, email, password }) 6 .then((res) =\u0026gt; { 7 const user = res as IUserState 8 this.set_user(user) 9 return user 10 }) 11 .catch((err) =\u0026gt; { 12 if (err.config \u0026amp;\u0026amp; err.config.url) 13 throw new Error(\u0026#34;API Server 환경을 검토하십시오.\u0026#34;) 14 else 15 throw new Error(err.message) 16 }) 17 } 18...    위의 코드에서와 같이 @Action({ rawError: true })  를 설정하면 해결된다. 단, 다른 원인에 의해서 발생하는 경우는 해당 원인을 파악해 본후에 적용해야 한다.\n 참고 자료  opn  "
},
{
	"uri": "http://ccambo.github.io/Dev/Vue/what-is-the-store-in-vuex/",
	"title": "Vuex의 Store란 무엇일까?",
	"tags": ["Vuex", "Store"],
	"description": "",
	"content": " Vue 개발에서 상태를 관리해 주는 기능을 제공해 주는 것이 Vuex이고 어플리케이션의 모든 컴포넌트들에 대한 중앙 집중식 저장소의 역할 및 관리  를 담당한다.\n  Vuex는 상태관리 패턴 + 라이브러리이며, Vue의 공식 툴이며 ES2015 문법을 기준으로 한다. Promise를 지원하지만, 혹시 지원하지 못하는 브라우저를 생각해야 한다면 es6-promise도 설치해 줘야 한다.   Vuex가 없다면 컴포넌트간의 데이터(상태)를 주고 받기 위해서 부모는 자식에서 props를 통해서 전달하고, 자식은 부모에게 Emit event 방식을 사용해서 처리해야 한다. (이전 게시글의 컴포넌트간의 관계를 참고) 더 큰 문제는 형제 컴포넌트간의 데이터 전달로 EventBus를 사용해야할 정도로 복잡해진다. 이런 문제점들이 간단한 어플리케이션의 경우는 어떻게든 풀어볼 수 있겠지만 대규모 어플리케이션이라면 감당할 수 없을 것이다.\n위와 같은 상황들을 해결해 주는 것이 Vuex라고 생각하면 된다. 즉, 데이터를 Store라는 곳을 통해서 관리하고 프로젝트에 존재하는 모든 컴포넌트들이 이 Store를 사용하는 것이다.\n[ 출처 - Vuex공식문서 : Vuex 위치 및 역할 ]  State, Mutations, Actions, Getters Vuex의 핵심구성 요소들은 State, Mutations, Actions, Getters 들이다.\nState (데이터 객체)  State는 쉽게 생각하면 공통으로 참조하기 위한 변수를 정의한 것이다. 프로젝트의 모든 곳에서 이를 참조하고 사용할 수 있다. 모든 컴포넌트들에서 공통된 값을 사용할 수 있다.   State 예  export const state = () =\u0026gt; ({ account: null, isAdmin: null, item: null })    Mutations (동기형 State 변경 처리기)  State 변경을 담당한다. 반드시 Mutation을 통해서만 State를 변경해야 한다. 동기 처리 기준이다. commit('함수명, \u0026lsquo;전달인자\u0026rsquo;)` 방식으로 호출한다. mutations 내에 함수들을 작성한다.   Mutations 예  export const mutations = { currentUser(state, account) { state.account = account } }    Actions (Mutation 트리거)  Mutation을 실행시키는 역할을 담당한다. 비동기 처리 기준이다. dispatch('함수명', '전달인자') 방식으로 호출한다. Actions 내에 함수들을 작성한다. 비동기 기준이므로 주로 콜백 함수로 작성한다.  일반적인 호출 방식\n 일반적인 호출 예  // 호출 예 dispatch(\u0026#39;setAccount\u0026#39;, account); // actions 정의 in store export const actions = { setAccount({commit, dispatch}, account) { commit(\u0026#39;currentUser\u0026#39;, account); // Mutation 실행  dispatch(\u0026#39;setIsAdmin\u0026#39;, account.uid); } }    컴포넌트에서 콜백 실행 방식\n 콜백 호출 예  // 호출 예 dispatch(\u0026#39;setAccount\u0026#39;, account).then(() =\u0026gt; {}); // actions 정의 in store export const actions = { setAccount({commit}, account) { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { commit(\u0026#39;currentUser\u0026#39;, account); // Mutation 실행  resolve(); // 콜백 처리  }, 1000) }) } }    Getters (공통 속성)  각 컴포넌트의 계산된 속성 (computed) 의 공통 속성으로 정의 여러 컴포넌트에서 동일한 computed가 사용될 경우 Getters에 정의해서 공통으로 쉽게 사용 가능 하위 모듈의 Getters를 불러오기 위해서는 this.$store.getters['경로명/함수명'];을 사용 (Store Instance Property 사용)   Getters 예  export const getters = { // 현재 로그인 상태 여부 확인 (user 정보 설정 여부로 true/false)  isAuthenticated(state) { return !!state.user; }, // 회원정보 불러오기  getAccount(state) { return state.account; } }    Vuex의 데이터 처리 관계 Vuex의 클래스는 state, mutations, actions, getters 로 구성되며 아래와 같이 구현된다.\n Vuex 클래스 구현 예 (store/index.js)  import { Auth, DB, ... } from \u0026#39;@/services/...\u0026#39; export const strict = false; /* ** States */ export const state = () =\u0026gt; ( ... ); /* ** Mutations */ export const mutations = { ... }; /* ** Actions */ export const actions = { ... }; /* ** Getters */ export const actions = { ... };    위의 형태는 모듈별로 구현하기 위한 구조로 각 용도에 따른 Store 구성을 위한 것이다. 예를 들면 User, Product, .... 과 같은 용도별 클래스 구성을 말한다.\nVuex의 처리 흐름은 일반적으로 아래의 그림과 같다.\n[ Vuex Store 데이터 흐름 ]  RootState Vuex 모듈 개발방식에서는 State 변수 값들은 동일 모듈에 있는 State만 참조하도록 제한된다. 만일 다른 모듈 또는 최 상위 State에 대한 활용이 필요한 경우는 해당 State에 직접 접근하는 것이 아니라 rootState를 활용해야 하고 Actions와 Getters의 인자로만 사용 가능하다. 예를 들어 Mutation쪽에서 사용하고 싶은 경우는 Actions에서 인자로 받아서 Mutation쪽으로 commit을 통해서 활용하는 방식으로 처리하게 된다.\nMutations 와 Actions 의 사용 가능 파라미터 규칙 Mutations 함수 파라미터\nMutations 내의 함수에 사용할 수 있는 파라미터들은 (state, payload) 로 한정된다. 즉, 기본적으로 사용할 수 있는 파라미터는 state만 가능하고, Commit을 통해서 전달된 파라미터는 payload만 가능하기 때문에 전달할 때 여러개의 정보가 필요하다면 객체형식으로 전달하면 된다.\n Mutations 파라미터  // Mutations fuction signature funtion_name (state, payload) { .... } // payload는 commit을 통해서 전달됨 // 여러 정보는 객체 형식으로 처리 function_name (state, { ... }) { ... }    Actions 함수 파라미터\nActions는 기본적으로 비동기 처리를 수행하므로 실행 후 응답이 도착한 순서대로 처리하게 된다. 따라서 파라미터들은 ({ rootState, state, dispatch, commit}, payload) 들로 한정된다. 기본 인자는 객체 형식으로 전달된다. payload도 역시 객체 방식으로 여러 정보를 묶어서 전달할 수 있다.\n Actions 파라미터  // Actions fuction signature funtion_name ({ rootState, state, dispatch, commit }, payload) { .... } // 여러 정보는 객체 형식으로 처리 function_name ({ rootState, state, dispatch, commit }, { ... }) { ... }    Component에서 Store를 사용하는 방법 State 사용 State에 접근하는 것은 Component의 computed 영역내에서 가능하다.\n 기본 접근 방법: this.$store.state.items mapState 활용    mapState 활용방법  computed: { mapState({ items: state =\u0026gt; state.items // this.items 속성을 this.$store.state.items 에 매핑  }), ... }    Mutations 사용 Mutations에 접근하는 것은 Component의 Methods 영역내에서 가능하다.\n 기본 접근 방법: this.$store.commit('경로명/함수명') mapMutations 활용   mapMutations 활용방법  methods: { mapMutations({ add: \u0026#39;item/increment\u0026#39; // this.add() 메서드를 this.$store.commit(\u0026#39;item/increment\u0026#39;) 에 매핑  }), ... }    Actions 사용 Actions에 접근하는 것은 Component의 Methods 영역내에서 가능하다.\n 기본 접근 방법: this.$store.commit('경로명/함수명') mapActions 활용   mapActions 활용방법  methods: { mapActions({ add: \u0026#39;item/increment\u0026#39; // this.add() 메서드를 this.$store.dispatch(\u0026#39;item/increment\u0026#39;) 에 매핑  }), ... }    Getters 사용 Getters에 접근하는 것은 Component의 computed 영역내에서 가능하다.\n 기본 접근 방법: this.$store.getters['경로명/함수명'] mapGetters 활용   mapGetters 활용방법  computed: { mapGetters({ doneCount: \u0026#39;item/doneTodosCount\u0026#39; // this.doneCount 속성을 this.$store.getters[\u0026#39;item/doneTodosCount\u0026#39;] 에 매핑  }), ... }    모듈로 구성된 Vuex에서 상위 모듈에 있는 dispatch, commit 실행 방법 모듈로 구성한 경우는 하위 모듈에서 형제 또는 부모 모듈의 State에 접근하기 위해서는 rootState를 사용하는 것과 같이 Mutations나 Actions를 실행시킬 경우는 3번쨰 파라미터로 {root: true} 를 지정하면 된다.\n 형제 또는 부모의 Mutations나 Actions 실행하기 위한 Signature  dipatch(\u0026#39;paths/function\u0026#39;, payload, {root: true}); commit(\u0026#39;paths/function, payload, {root: true});    이제 최상위 경로인 root 부터 하위로 경로를 찾아서 처리가 된다.\n좀 더 잘 활용할 수 있는 방법은? 검증하면서 걱정이 되었던 부분은 상태 데이터가 커지게 되면 State, Actions, Getters, Mutations 관리가 제대로 가능할지에 대한 것이다. 이런 문제점들과 관련해서 여러 가지 문서들과 샘플들을 확인해 보면 아래와 같이 몇 가지 패턴들을 제공하고 있는 것 같다. 실제 코드를 작성하면서 검증한 것이 아니라 지금까지의 경험에 비해서 추론적으로 판단한 것이기 때문에 실제와 다를 수도 있다.\n패턴 적용에 대한 검토 vuex도 react+redux 에서처럼 구조적으로 잘 활용할 수 있도록 다양한 방법과 패턴들을 제공하고 있지만, 오히려 다양함이 더 혼란을 주는것 같고, 뭔가 불필요한 중복 요소들이 생기는 것 같아서 아래와 같이 패턴들을 적용하면서 나름대로 문제점들을 정리하는 방식으로 좀 더 간략하게 사용할 수 있는 방법을 검토해 본다.\nNamespace를 활용한 모듈 패턴 적용\n관련 문서들을 뒤져보면 namespaced  를 통해서 모듈처리하는 것에 대한 부분이 존재한다.\n @/store/modules/\u0026lt;module_name\u0026gt; 과 같이 사용할 Store 모듈 경로를 구성한다. 경로 밑으로 state.js, getters.js, mutations.js, actions.js 로 분리해서 파일을 구성한다. 경로 밑의 index.js 에서 namespaced: true 옵션으로 export 처리한다.   문제는 각 기능별로 소스를 분리해 처리하는 것은 좋은데, 변경(네임스페이스, 메서드 명, \u0026hellip;)이 발생하면 이에 따른 수정 요소들이 꼬리를 물고 발생할 가능성이 높다.\nBinding Helper 패턴 적용\n관련 문서를 뒤져보면 mapXXXX  방식으로 Binding Helper를 통해서 처리하는 부분이 존재한다.\n mapActions, mapState, mapGetters, mapMutations의 바인딩 Helper를 자체적으로 제공한다. namespace가 필요한 경우에는 binding helper에 첫번쨰 아규먼트로 추가해 주면 된다.  이 방식을 사용하면 하나의 파일에서 좀 더 쉽게 코드를 구성할 수는 있을 것 같은데 Helper의 변경이 발생하거나 확장하는데 제한이 발생할 수 있을 것 같다. 문제는 이 패턴에 대한 접근 방법이 일관적이지 않고 아래와 같이 Namepsace를 먼저 만들고 Binding Helper를 적용하는 방법도 존재한다는 점이다. 그리고 네임스페이스, 메서드 명등의 변경으로 발생하는 문제는 똑같이 존재한다.\nNamespace를 적용한 Binding Helper 패턴 적용\nVuex에서 제공하는 createNamespaceHelpers를 사용해서 Namespace를 먼저 구성한 후에 mapState, mapMutations, mapActions, mapGetters를 구성하는 방법이다. 사용법은 BindingHelper를 사용하는 방법 그대로 적용할 수 있다.\n createNamespaceHelpers 사용 (Store module)  import { createNamespaceHelpers } from \u0026#39;vuex\u0026#39; ... const { mapState, mapGetters, mapActions, mapMutations } = createNamespaceHelpers(\u0026#34;your_namespace\u0026#34;) ... export { mapState, mapGetters, mapActions, mapMutations }    매번 Binding Helper를 사용할때 지정하던 namespace를 한번만 처리하고 사용하기 때문에 namespace 중복 지정의 문제는 해결이 된 셈이다. 그러나 아직도 문제는 남아 있다. 코드를 작성하다 보면 State/Mutation 에서 중복이 많이 발생하고 Actions/Getters 에서도 거의 중복에 가까운 처리하게 된다.\n상수 분리 적용\n모듈에서 상수만을 따로 정의하는 코드를 작성하고 이 상수를 사용하는 방식을 추가하면 상수 (메서드 명 등\u0026hellip;)를 중복 사용하는 문제를 해결할 수 있다. 물론 수정이 발생해도 한군데서만 적용하면 된다. 나중에는 상수명과 실제 함수명등이 달라지는 것이 문제겠지만\u0026hellip;\n##결론##\n이 문서는 완성된 샘플을 기준으로 한 것이 아니라 검토하면서 계속 진행되고 있는 것이기 때문에 Vuex에 대한 기준 설명은 변동이 없지만 실제 사용하는데 필요한 샘플 코드들을 명확하게 작성하지는 못하고 있다. 위에서 설명했던 모듈 방식의 활용은 vuex-module-decorators  패키지를 이용해서 좀 더 간단하게 구성할 수 있을 듯 하기 때문에 향후 재 작성을 할 예정이다.\n참고 자료  Vuex가 무엇인가요?  "
},
{
	"uri": "http://ccambo.github.io/Dev/Vue/How-to-use-vue-property-decorator/",
	"title": "vue-property-decorator 정리",
	"tags": ["Vue", "vue-property-decorator"],
	"description": "",
	"content": " 현재 진행 중인 Vue.js + Typescript 기반의 프로젝트에서 컴포넌트 구성에 필요한 부분을 정리한 것으로 Typescript로 구성하면 자바스크립트로 어떻게 구성되는지를 비교하면서 진행하도록 한다.\n특이한 코드 설정 (readonly, !) Typescript를 사용하면서 \u0026lsquo;?\u0026rsquo;  는 생략 가능 또는 null / undefined도 가능하다라는 코드는 많이 봤을테지만 vue-property-decorator 샘플들을 보면 \u0026lsquo;readonly, !:\u0026rsquo;  와 같은 생소한 코드를 보게 된다.\nreadonly 대상 멤버를 읽기 전용으로 한정하겠다는 한정자 (OOP 언어에서는 많이 사용)로 Vue에서 Prop이나 Model 등에 readonly를 한정했을 떄 할당을 하면 오류가 발생하게 된다. 따라서 데코레이터들을 사용할 때는 @Prop이나 @Model 등에 readonly 한정자를 선언하는 것이 좋다.\n Typescript - reaonly 한정자 선언  1... 2\u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; 3import { Component, Model, Prop, PropSync, Vue } from \u0026#39;vue-property-decorator\u0026#39;; 4 5@Component 6export default class SampleComponent extends Vue { 7 @Prop(String) readonly name: string; 8 @Model(\u0026#39;update\u0026#39;, { type: Object }) readonly profile: IProfile; 9 @PropSync(String) value: string; // 할당 가능 10} 11\u0026lt;/script\u0026gt; 12...   ! 대상 멤버에 대한 NonNullAssersion 오퍼레이터로 \u0026ldquo;!\u0026ldquo;가 붙은 경우는 null / Undefined를 설정할 수 없음을 나타내는 것이다. 그러나 너무 남용하면 특정 형식에 대한 값을 확정하고 처리하는 것이 때문에 확장성에 제한을 받는 상황이 될 수 있으므로 가능하면 \u0026ldquo;required: true\u0026rdquo; 이거나 \u0026ldquo;기본 값\u0026rdquo;을 설정하는 경우에 지정하는 것이 좋다.\n Typescript - reaonly 한정자 선언  1... 2\u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; 3import { Component, Prop, Vue } from \u0026#39;vue-property-decorator\u0026#39;; 4 5@Component 6export default class SampleComponent extends Vue { 7 @Prop({ type: String, required: true }) readonly name!: string; 8 @Prop({ type: Array, default: () =\u0026gt; [] }) readonly items!: string[]; 9 @Prop(Object) readonly profile?: IProfile; // null / undefined 가능 10} 11\u0026lt;/script\u0026gt; 12...   @Component (vue-class-component) @Component  는 정의한 클래스를 Vue 가 인식할 수 있는 형태로 변환하는 것을 의미한다.\n Typescript - @Component 선언  1... 2\u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; 3import { Component, Vue } from \u0026#39;vue-property-decorator\u0026#39;; 4 5@Component 6export default class SampleComponent extends Vue {} 7\u0026lt;/script\u0026gt; 8...    Javascript 변환 - Vue Component  1... 2\u0026lt;script\u0026gt; 3export default { 4 name: \u0026#39;SampleComponent\u0026#39; 5}; 6\u0026lt;/script\u0026gt; 7...   컴포넌트의 내부 구성을 처리하기 전에 컴포넌트 자체의 옵션들을 설정할 수 있으며 이를 통해서 각 종 Vue 객체들과 연동 정보를 구성할 수 있다. 많이 사용되는 것들은 아래와 같다.\n Child Components Directives Filters Mixins Data DOM Life-cycle Hooks Asset Configuration   Typescript - @Component 옵션 설정  1... 2\u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; 3import { Component, Vue } from \u0026#39;vue-property-decorator\u0026#39;; 4 5@Component({ 6 components: { 7 AppButton, 8 ProductList 9 }, 10 directives: { 11 resize 12 }, 13 filters: { 14 dateFormat 15 }, 16 mixins: [ 17 PageMixin 18 ] 19}) 20export default class SampleComponent extends Vue {} 21\u0026lt;/script\u0026gt; 22...    Javascript 변환 - Vue Component  1... 2\u0026lt;script\u0026gt; 3export default { 4 name: \u0026#39;SampleComponent\u0026#39;, 5 components: { 6 AppButton, 7 ProductList 8 }, 9 directives: { 10 resize 11 }, 12 filters: { 13 dateFormat 14 }, 15 mixins: [ 16 PageMixin 17 ] 18}; 19\u0026lt;/script\u0026gt; 20...   @Prop 컴포넌트 내의 지정한 멤버들을 속성(props)으로 사용할 수 있도록 구성한다.\n @Prop(options: (PropOptions | Constructor[] | Constructor) = {})\n  Typescript - @Prop 선언  1... 2\u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; 3import { Component, Prop, Vue } from \u0026#39;vue-property-decorator\u0026#39;; 4 5@Component 6export default class SampleComponent extends Vue { 7 @Prop(Number) readonly propA: number | undefined 8 @Prop({ default: \u0026#39;default value\u0026#39; }) readonly propB!: string 9 @Prop([String, Boolean]) readonly propC: string | boolean | undefined 10} 11\u0026lt;/script\u0026gt; 12...    Javascript 변환 - Vue Component  1... 2\u0026lt;script\u0026gt; 3export default { 4 name: \u0026#39;SampleComponent\u0026#39;, 5 props: { 6 propA: { 7 type: Number 8 }, 9 propB: { 10 default: \u0026#39;default value\u0026#39; 11 }, 12 propC: { 13 type: [String, Boolean] 14 } 15 } 16}; 17\u0026lt;/script\u0026gt; 18...   @Watch 지정한 대상을 모니터링해서 변경되었을 떄 처리를 수행한다.\n 첫번째 인수 : 모니터링 대상 값 두번쨰 인수 : 모니터링 옵션   @Watch(path: string, opitons: WatchOptions = {})\n  Typescript - @Watch 선언  1... 2\u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; 3import { Component, Watch, Vue } from \u0026#39;vue-property-decorator\u0026#39;; 4 5@Component 6export default class SampleComponent extends Vue { 7 @Watch(\u0026#39;child\u0026#39;) 8 onChildChanged(val: string, oldVal: string) {} 9 10 @Watch(\u0026#39;person\u0026#39;, { immediate: true, deep: true }) 11 onPersonChanged1(val: Person, oldVal: Person) {} 12 13 @Watch(\u0026#39;person\u0026#39;) 14 onPersonChanged2(val: Person, oldVal: Person) {} 15} 16\u0026lt;/script\u0026gt; 17...    Javascript 변환 - Vue Component  1... 2\u0026lt;script\u0026gt; 3export default { 4 name: \u0026#39;SampleComponent\u0026#39;, 5 watch: { 6 child: [ 7 { 8 handler: \u0026#39;onChildChanged\u0026#39;, 9 immediate: false, 10 deep: false 11 } 12 ], 13 person: [ 14 { 15 handler: \u0026#39;onPersonChanged1\u0026#39;, 16 immediate: true, 17 deep: true 18 }, 19 { 20 handler: \u0026#39;onPersonChanged2\u0026#39;, 21 immediate: false, 22 deep: false 23 } 24 ] 25 }, 26 methods: { 27 onChildChanged(val, oldVal) {}, 28 onPersonChanged1(val, oldVal) {}, 29 onPersonChanged2(val, oldVal) {} 30 } 31}; 32\u0026lt;/script\u0026gt; 33...   위의 코드에서 Watch 옵션으로 지정한 immediate는 컴포넌트 초기화시에도 실행할지 여부를 지정한 것이다.\n @Watch는 대상 변경에 따른 이벤트 처리기와 같은 기능을 수행하기 때문에 동일한 대상을 여러 번 지정할 경우는 가장 마지막에 지정한 것만 유효하다.\n @PropSync Vue.js에서는 props를 정의할 때 .sync 를 지정해서 자식 컴포넌트에서 부모 컴포넌트의 값을 변경할 수 있도록 처리할 수 있으며 @update: 이벤트를 수신하면 Data에 적용하는 처리가 암시적으로 진행된다.\n @PropSync(propName: string, options: (PropOptions | Constructor[] | Constructor) = {})\n  Template - 부모 컴포넌트  1\u0026lt;template\u0026gt; 2 \u0026lt;!-- 아래의 두 가지 Child 컴포넌트 설정은 동일한 의미를 가진다. 단지 명시적인 표현 여부만 다르다. --\u0026gt; 3 \u0026lt;ChildComponent :childValue.sync=\u0026#34;value\u0026#34; /\u0026gt; 4 \u0026lt;ChildComponent :childValue=\u0026#34;value\u0026#34; @update:childValue=\u0026#34;value = $event\u0026#34; /\u0026gt; 5\u0026lt;/template\u0026gt;   @PropSync는 자식 컴포넌트에서 부모 컴포넌트의 .sync 속성을 전달할때 사용하는 데코레이터로 아래와 같이 사용해서 값을 할당하는 것만으로 처리가 가능하다.\n Typescript - 자식 컴포넌트에서 @PropSync 선언  1... 2\u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; 3import { Component, PropSync, Vue } from \u0026#39;vue-property-decorator\u0026#39;; 4 5@Component 6export default class SampleComponent extends Vue { 7 @PropSync({ type: String }) childValue: string; 8 ... 9 // 값 변경 적용 10 updateValue(newVal: string) { 11 this.childValue = newVal; // 이 시점에서 부모 컴포넌트로 전달된다. 12 } 13} 14\u0026lt;/script\u0026gt; 15...   @PropSync를 사용하지 않는다면 아래와 같이 이벤트 호출을 처리해 줘야 한다.\n Typescript - 자식 컴포넌트에서 직접 처리하는 경우  1... 2\u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; 3import { Component, Prop, Vue } from \u0026#39;vue-property-decorator\u0026#39;; 4 5@Component 6export default class SampleComponent extends Vue { 7 @Prop({ type: String }) childValue: string; 8 ... 9 // 값 변경 적용 10 updateValue(newVal: string) { 11 this.$emit(\u0026#39;update:childValue\u0026#39;, newVal); // 값 설정 및, 부모 컴포넌트로 이벤트 전달 12 } 13} 14\u0026lt;/script\u0026gt; 15...   @Emit Vue.js에서는 컴포넌트간의 데이터 연동이 가능하다.\n 부모에서 자식으로 전달은 props 사용 자식에서 부모로 전달은 event 사용  자식에서 부모로 값을 전달하는 event 처리에 사용하는 것이 @Emit다.\n @Emit(event?: string)\n  Typescript - 자식 컴포넌트  1\u0026lt;template\u0026gt; 2 \u0026lt;form @submit=\u0026#34;onSubmit\u0026#34;\u0026gt; 3 \u0026lt;input v-model=\u0026#34;value\u0026#34;\u0026gt; 4 \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;Submit\u0026lt;/button\u0026gt; 5 \u0026lt;/form\u0026gt; 6\u0026lt;/template\u0026gt; 7 8\u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; 9import { Component, Vue } from \u0026#39;vue-property-decorator\u0026#39;; 10 11@Component 12export default class ChildComponent extends Vue { 13 value = \u0026#39;\u0026#39;; 14 15 // 부모로 값 전달 16 onSubmit() { 17 this.$emit(\u0026#39;submit\u0026#39;, this.value); 18 } 19} 20\u0026lt;/script\u0026gt;    Typescript - 부모 컴포넌트  1\u0026lt;template\u0026gt; 2 \u0026lt;ChildComponent @submit=\u0026#34;onReceiveSubmit\u0026#34; /\u0026gt; 3\u0026lt;/template\u0026gt; 4 5\u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; 6import { Component, Vue } from \u0026#39;vue-property-decorator\u0026#39;; 7import ChildComponent form \u0026#39;@/components/childcomponent.vue\u0026#39;; 8 9@Component({ 10 components: { 11 ChildComponent 12 } 13}) 14export default class ParentComponent extends Vue { 15 async onReceiveSubmit(newVal: string) { 16 // $emit을 통해서 전달된 값 수신 17 await this.$request.post(newVal); 18 } 19} 20\u0026lt;/script\u0026gt;   위의 예제에서 ChildComponent는 직접 $emit 처리를 했지만 이를 @Emit 사용하는 버전으로 바꾸면 좀 더 단순하게 코드를 구성할 수 있다. 처리되는 이벤트의 이름은 @emit의 옵션을 설정해서 구분할 수도 있지만 생략할 경우는 메서드의 이름을 그대로 이벤트 이름으로 사용한다.\n Typescript - 자식 컴포넌트 @Emit 선언  1\u0026lt;template\u0026gt; 2 \u0026lt;form @submit=\u0026#34;onSubmit\u0026#34;\u0026gt; 3 \u0026lt;input v-model=\u0026#34;value\u0026#34;\u0026gt; 4 \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;Submit\u0026lt;/button\u0026gt; 5 \u0026lt;/form\u0026gt; 6\u0026lt;/template\u0026gt; 7 8\u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; 9import { Component, Emit, Vue } from \u0026#39;vue-property-decorator\u0026#39;; 10 11@Component 12export default class ChildComponent extends Vue { 13 value = \u0026#39;\u0026#39;; 14 15 // 부모로 값 전달, 옵션이 없더라도 \u0026#39;()\u0026#39;를 생략할 수 없다. 16 // return으로 반환된 값이 전달되며, 메서드 이름을 사용할 경우는 \u0026#39;on\u0026#39; 접두사가 붙어서 처리된다. 17 @Emit() 18 submit() { 19 return this.value; 20 } 21} 22\u0026lt;/script\u0026gt;   @Ref @Ref는 $refs에서 참조할 수 있는 요소 또는 컴포넌트를 정의하는 것으로 사전에 정의함으로서 오타나 수정에 대응하기 쉽도록 하는 역할을 담당한다.\n @Ref(refKey?: string)\n  Typescript - @Ref 선언  1\u0026lt;template\u0026gt; 2 \u0026lt;ChildComponent ref=\u0026#34;childComponent\u0026#34; /\u0026gt; 3 \u0026lt;button ref=\u0026#34;submitButton\u0026#34;\u0026gt;Submit\u0026lt;/button\u0026gt; 4\u0026lt;/template\u0026gt; 5 6\u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; 7import { Component, Ref, Vue } from \u0026#39;vue-property-decorator\u0026#39;; 8 9@Component({ 10 components: { 11 ChildComponent 12 } 13}) 14export default class SampleComponent extends Vue { 15 @Ref() childComponent: ChildComponent; 16 @Ref() submitButton: HTMLButtomElement; 17 18 mounted() { 19 // 자식 컴포넌트 메서드 실행 20 this.childComponent.updateValue(); 21 // 버튼에 포커스 설정 22 this.submitButton.focus() 23 } 24} 25\u0026lt;/script\u0026gt;   @Model Vue.js의 Model을 정의하는 것으로 여러 가지 옵션을 정의할 수 있다. @Model이 정의되면 해당 변수가 @Prop 선언을 동반하게 된다.\n @Model(event?: string, options: (PropOptions | Constructor[] | Constructor) = {})\n  Typescript - @Model 선언  1... 2\u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; 3import { Component, Model, Vue } from \u0026#39;vue-property-decorator\u0026#39;; 4 5@Component 6export default class SampleComponent extends Vue { 7 @Model(\u0026#39;change\u0026#39;, { type: Boolean }) readonly checked!: boolean 8} 9\u0026lt;/script\u0026gt; 10...    Javascript 변환 - Vue Component  1... 2\u0026lt;script\u0026gt; 3export default { 4 name: \u0026#39;SampleComponent\u0026#39;, 5 model: { 6 prop: \u0026#39;checked\u0026#39;, 7 event: \u0026#39;change\u0026#39; 8 }, 9 props: { 10 checked: { 11 type: Boolean 12 } 13 } 14}; 15\u0026lt;/script\u0026gt; 16...   @Provide / @Inject 부모 컴포넌트에서 @Provide로 정의된 대상을 자식 컴포넌트에서 @Inject로 참조할 수 있다.\n @Provide(key?: string | Symbole)  @Inject(options?: { from?: InjectKey, default?: any } | InjectKey)\n  Typescript - @Provide / @Inject 선언  1... 2\u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; 3import { Component, Inject, Provide, Vue } from \u0026#39;vue-property-decorator\u0026#39;; 4 5const symbol = Symbol(\u0026#39;baz\u0026#39;); 6 7@Component 8export default class SampleComponent extends Vue { 9 @Inject() readonly foo!: string; 10 @Inject(\u0026#39;bar\u0026#39;) readonly bar!: string 11 @Inject({ from: \u0026#39;optional\u0026#39;, default: \u0026#39;default\u0026#39; }) readonly optional!: string 12 @Inject(symbol) readonly baz!: string 13 14 @Provide() foo = \u0026#39;foo\u0026#39; 15 @Provide(\u0026#39;bar\u0026#39;) baz = \u0026#39;bar\u0026#39; 16} 17\u0026lt;/script\u0026gt; 18...    Javascript 변환 - Vue Component  1... 2\u0026lt;script\u0026gt; 3const symbol = Symbol(\u0026#39;baz\u0026#39;) 4 5export default { 6 name: \u0026#39;SampleComponent\u0026#39;, 7 inject: { 8 foo: \u0026#39;foo\u0026#39;, 9 bar: \u0026#39;bar\u0026#39;, 10 optional: { from: \u0026#39;optional\u0026#39;, default: \u0026#39;default\u0026#39; }, 11 [symbol]: symbol 12 }, 13 data() { 14 return { 15 foo: \u0026#39;foo\u0026#39;, 16 baz: \u0026#39;bar\u0026#39; 17 } 18 }, 19 provide() { 20 return { 21 foo: this.foo, 22 bar: this.baz 23 } 24 } 25}; 26\u0026lt;/script\u0026gt; 27...   @ProvideReactive / @InjectReactive \u0026rdquo;@Provide / @Inject\u0026rdquo; 의 확장 기능으로 부모 컴포넌트에서 @ProvideReactive로 제공된 대상이 변경되면 자식 컴포넌트에서 인식할 수 있다.\n @ProvideReactive(key?: string | symbol)  @InjectReactive(options?: { from?: InjectKey, default?: any } | InjectKey )\n  Typescript - @ProvideReactive / @InjectReactive 선언  1... 2\u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; 3import { Component, InjectReactive, ProvideReactive, Vue } from \u0026#39;vue-property-decorator\u0026#39;; 4 5const key = Symbol() 6 7// 부모 컴포넌트 8@Component 9export default class ParentComponent extends Vue { 10 @ProvideReactive() one = \u0026#39;value\u0026#39; 11 @ProvideReactive(key) two = \u0026#39;value\u0026#39; 12} 13 14// 자식 컴포넌트 15@Component 16export default class ChildComponent extends Vue { 17 @InjectReactive() one!: string 18 @InjectReactive(key) two!: string 19} 20\u0026lt;/script\u0026gt; 21...   참고 자료  Vue Property Decorator - Github  "
},
{
	"uri": "http://ccambo.github.io/Dev/Nuxt/how-to-use-axios-in-nuxt/",
	"title": "Nuxt에 AXIOS 적용하기",
	"tags": ["Nuxt", "Axios"],
	"description": "Axios는 Nuxt 커뮤니티에서 공식으로 지원하는 모듈로 이에 대한 기본적인 사용법과 적용 방법을 정리하고 있습니다.",
	"content": " Axios란? Axios는 Promise 기반의 자바스크립트 비동기 처리 방식을 사용하고 있기 때문에 아래와 같이 서버를 호출한 후에 반횐되는 콜백함수를 통해서 결과를 처리하는 방식으로 운영된다.\n axios 기본 사용법  axios.get(\u0026#39;/api/data\u0026#39;) .then(res =\u0026gt; { console.log(res.data); });    설치는 프로젝트에 axios 패키지를 설정하면 된다.\n axios 패키지 설치  $ npm install -s axios # 또는 $ yarn add axios   요즘 그럴일은 없겠지만 단순한 웹구성을 사용하고 있다면 직접 웹페이지에 스크립트를 지정해서 사용할 수도 있다.\n axios 스트립트 설정  ... \u0026lt;head\u0026gt; ... \u0026lt;script src=\u0026#34;https://unpkg.com/axios/dist/axios.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; ... \u0026lt;/head\u0026gt; ...   AXIOS 사용하기 axios는 REST 메서드 이름을 별칭으로 사용하기 때문에 사용하기 쉽다.\n 데이터 가져오기 (GET): axios.get(url[, config]) 데이터 등록오기 (POST): axios.post(url[, data[, config]]) 데이터 수정하기 (PATCH): axios.patch(url[, data[, config]]) 데이터 삭제하기 (DELETE): axios.delete(url[, config])  GET 처리하기 서버에서 데이터를 가져오는 용도로 가장 많이 사용되는 명령이다.\n axios get 예제  // 단순 데이터 조회 axios.get(\u0026#39;/aip/data/1\u0026#39;) .then(res =\u0026gt; { console.log(`status: ${res.status}`); // 응답 Status code  console.log(`headers: ${res.headers}`); // 응답 Headers  console.log(`data: ${res.data}`); // 응답 Data  }); // 요청 데이터 포함 axios.get(\u0026#39;/api/data\u0026#39;, { params: { title: \u0026#39;axios test\u0026#39; }, // 요청으로 전달할 데이터  headers: { \u0026#39;X-Api-Key\u0026#39;: \u0026#39;my-api-key\u0026#39; }, // Header로 전달할 데이터  timeout: 1000 // Timeout 1초. 지나면 오류 처리 }).then(res =\u0026gt; { console.log(res.data) });    POST 처리하기 서버로 데이터를 등록(입력)할 떄 사용되는 명령이다.\n axios post 예제  axios.post(\u0026#39;/aip/data\u0026#39;, { title: \u0026#39;axios test\u0026#39; }).then(res =\u0026gt; { console.log(res.data) });    PATCH 처리하기 서버의 특정한 데이터를 수정할 때 사용되는 명령이다.\n axios patch 예제  axios.post(\u0026#39;/aip/data/3\u0026#39;, { title: \u0026#39;axios test\u0026#39; }).then(res =\u0026gt; { console.log(res.data) });    DELETE 처리하기 서버의 특정한 데이터를 삭제할 때 사용되는 명령이다.\n axios delete 예제  axios.post(\u0026#39;/aip/data/3\u0026#39;) .then(res =\u0026gt; { console.log(res.data) });    FILE Upload 하기 HTML 구문을 Upload로 사용하기 위해서 Form 구성을 아래와 같이 한다.\n Form 구성 예제  \u0026lt;form method=\u0026#34;post\u0026#34; enctype=\u0026#34;multipart/form-data\u0026#34; action=\u0026#34;/content/data\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;image\u0026#34; ref=\u0026#34;photo\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34;\u0026gt; \u0026lt;/form\u0026gt;   FormData() 객체를 생성하고 this.$ref.photo 와 같이 ref 옵션을 이용해서 필드를 직접 참조를 해서 이미지 파일을 가져오고 업로드할 수 있다. 처리하는 스크립트는 아래와 같다.\n 이미지 업로드 예제  // FormData 생성 및 이미지 파일 가져오기 var data = new FormData(); var file = this.$ref.photo.files[0]; data.append(\u0026#39;photo\u0026#39;, file); // axios로 파일 업로드 처리 axios.post(\u0026#39;/api/data\u0026#39; + this.no + \u0026#39;photo\u0026#39;, data) .then((res) =\u0026gt; { this.result = res.data; }) .catch((ex) =\u0026gt; { console.log(\u0026#39;파일 업로드 실패:\u0026#39;, ex); });    Nuxt에 Axios 모듈 설정 및 사용하기 axios-module 은 Nuxt.js에서 공식 지원하는 모듈로 Nuxt 환경에서 Axios를 쉽고 안전하게 사용할 수 있도록 지원하는 것이다. 이 모듈에 대한 것은 API 사용법을 참고하도록 한다.\n모듈 설치 및 설정  axios 모듈 설치  $ yarn add @nuxtjs/axios   nuxt.config.js 파일의 modules 에 모듈을 등록한다. 여기에 등록된 모듈은 인스턴스 속성으로 처리되므로 this.$axios와 같이 사용이 가능하다.\n nuxt-config.js - axios 모듈 설정  ... module.exports = { ... modules: [ \u0026#39;@nuxtjs/axios\u0026#39;, ], ... axios: { // 모듈 설정  baseURL: process.env.BASE_URL || \u0026#39;your api server url\u0026#39; } ... }    @nuxtjs/axios 모듈 사용하기 nuxtServerInit 메서드와 actions 메서드의 사용법이 조금 다르기 때문에 아래 예제 코드를 잘 확인할 필요가 있다. 컴포넌트의 asyncData 메서드에서의 사용법은 nuxtServerInit 메서드와 동일하다.\n @nuxtjs/axios 사용 예 (/store/index.vue)  import Vuex from \u0026#39;vuex\u0026#39; // 환경 설정을 통해 모듈 등록을 했으므로 추가로 axios 모듈을 import할 필요는 없다.  const createStore = () =\u0026gt; { return new Vuex.Store({ sate: { loadedPosts: [] }, mutations: { // ...  }, actions: { async nuxtServerInit({ commit }, { app }) { try { // nuxtServerInit 에서는 axios.get() -\u0026gt; app.$asxios.$get() 을 사용하고  // nuxt.config.js에 BASE_URL을 설정했기 때문에 상대 경로만 설정하면 되고  // 결과는 데이터만 추출되기 때문에 Data를 바로 사용할 수 있다.  const data = await app.$axios.$get(\u0026#39;/posts.json\u0026#39;) const postsList = [] for (let key in data) { postsList.push({ ...data[key], id: key }) } } catch (e) { console.error(e) } }, setPosts({ commit }, posts) { commit(\u0026#39;setPosts\u0026#39;, posts) }, createPost({ commit }, createdPost) { createdPost.createdDate = new Date().toLocaleString(); createdPost.updatedDate = createdPost.createdDate // actions 메서드 내부에서는 this.$axios를 사용하고  // BASE_URL 설정에 따라서 상대 경로만 설정하고  // data 바로 사용  return this.$axios.$post(\u0026#39;posts.json\u0026#39;, createdPost) .then(data =\u0026gt; { commit(\u0026#39;createPost\u0026#39;, { ...createdPost, id: data.name }) }) .catch(e =\u0026gt; console.error(e)) }, updatePost({ commit }, updatedPost) { updatePost.updatedDate = new Date().toLocaleString() // actions 메서드 내부에서는 this.$axios를 사용하고  // BASE_URL 설정에 따라서 상대 경로만 설정하고  // data 바로 사용  return this.$axios.$put(\u0026#39;/posts/${updatedPost.id}.json\u0026#39;, updatedPost) .then(data =\u0026gt; { commit(\u0026#39;updatePost\u0026#39;, updatedPost) }) .catch(e =\u0026gt; console.error(e)) } }, getters: { loadedPosts(state) { return this.loadedPosts } } }) } export default createStore    Multiple Server 활용하기 Axios는 Proxy 옵션을 제공하고 있다. 옵션에 대한 자세한 내용을 참고하로도록 한다.\n우선 nuxt.config.ts 파일에 axios를 모듈로 등록해 줘야 옵션을 쉽게 설정하고 사용할 수 있다.\n nuxt.config.ts - axios 옵션 설정  ... modules: [ \u0026#34;@nuxtjs/axios\u0026#34; ] ... axios: { proxy: true // default: false, boolean or object 설정 가능  baseURL: .... credenital: true, debug: true, retry: { retries: 3 }, requestInterceptor: (config, {stroe}) =\u0026gt; { config.headers.common[\u0026#39;Authentication\u0026#39;] = ... config.headers.common[\u0026#34;Content-Type\u0026#39;] = ... return config } } ... proxy: { \u0026#39;/api/\u0026#39;: { target: \u0026#39;http://your.apiserver.com\u0026#39;,  pathRewrite: { \u0026#39;^/api:\u0026#39;: \u0026#39;\u0026#39;}, chagneOrigin: false, prependPath: false } \u0026#39;/api2/\u0026#39;: { target: \u0026#39;http://another.apiserver.com\u0026#39;, ... } ... } ...   기본적인 설정 방법은 위와 같이 처리를 하면 되고 실제로 사용할 때는 proxy로 지정한 서버의 식별자를 이용해서 처리하면 된다.\n참고 자료  axios - github axios 모듈 설정 ES6 Promise  "
},
{
	"uri": "http://ccambo.github.io/Cloud/Docker/",
	"title": "Docker",
	"tags": [],
	"description": "이 페이지는 Docker에 대한 관련된 정보들을 정리합니다.",
	"content": " Docker 관련 정보들 정리!!!  Tips  Docker 사용 중에 발생한 오류들의 해결방법이나 유용한 정보들을 정리합니다.\n "
},
{
	"uri": "http://ccambo.github.io/Cloud/Kubernetes/",
	"title": "Kubernetes",
	"tags": [],
	"description": "이 페이지는 Kubernetes에 관련된 정보를 정리합니다.",
	"content": " Kubernetes 관련 정보 정리!!!  "
},
{
	"uri": "http://ccambo.github.io/Cloud/Docker/Tips/",
	"title": "Tips",
	"tags": [],
	"description": "Docker 사용 중에 발생한 오류들의 해결방법이나 유용한 정보들을 정리합니다.",
	"content": " Errors and Tips "
},
{
	"uri": "http://ccambo.github.io/Git/Tips/",
	"title": "Tips",
	"tags": [],
	"description": "",
	"content": " Tips 이 문서에서는 Git 사용 중에 발생한 오류들의 해결 방법이나 유용한 정보들을 정리하고 있습니다.\n How to Change Users  Git 사용 중에 사용자 변경 관련 오류를 해결하는 방법을 정리합니다.\n "
},
{
	"uri": "http://ccambo.github.io/",
	"title": "MSFL",
	"tags": [],
	"description": "",
	"content": " 지식 저장소 여러 가지 정보들을 하나의 지식 저장소처럼 꾸미는 꿈을 가지고 진행하고 있습니다.\n Git  Git 관련 정보들 정리 이 문서에서는 Git 사용에 필요한 정보들을 정리하고 있습니다. Basics Basics 이 문서에서는 Git 사용에 필요한 기본적인 정보들을 정리하고 있습니다. Submodule Submodule 이 문서에서는 Git의 Submodule에 관련된 정보들을 정리하고 있습니다. What is the submodule Git의 Submodule에 관련된 내용을 정리합니다. Tips Tips 이 문서에서는 Git 사용 중에 발생한 오류들의 해결 방법이나 유용한 정보들을 정리하고 있습니다. How to Change Users Git 사용 중에 사용자 변경 관련 오류를 해결하는 방법을 정리합니다.\n Cloud   Cloud 이 문서에서는 Cloud에 필요한 정보들을 정리하고 있습니다. Concepts Concepts Cloud와 연계되는 개념들을 정리합니다. Edge Computing Edge Computing에 대한 내용을 정리합니다. Docker 이 페이지는 Docker에 대한 관련된 정보들을 정리합니다. Kubernetes 이 페이지는 Kubernetes에 관련된 정보를 정리합니다.  Dev  Developments 이 문서에서는 개발에 필요한 정보들을 정리하고 있습니다. Vue Vue Vue에 대한 소개 및 사용하는데 필요한 정보들을 정리합니다. Vue 키 포인트 소개 프로젝트에 Vue를 도입한 결정적인 이유 Vue 기본 개념 Vue.js에 대한 간략한 기본 개념 소개 Vuetify v2.x 업그레이드 Vue 및 Vuetify와 관련된 프로젝트를 v2.x 버전으로 업그레이드해서 작업할 때 발생하는 문제점들을 정리한다. Vuex의 Store란 무엇일까? Vue 개발에서 상태를 관리해 주는 기능을 제공해 주는 것이 Vuex이고 어플리케이션의 모든 컴포넌트들에 대한 중앙 집중식 저장소의 역할 및 관리 를 담당한다.\n FunnyLab  Funny Lab 엉뚱하고 재미있는 상상들을 정리하고 있습니다. Blogging Blogging 이 문서에서는 Hugo 및 Hexo 블로그 구성에 필요한 정보들을 정리하고 있습니다. 댓글 시스템 utterances로 변경 기존 Disqus 댓글 시스템의 문제점으로 Github연동형 댓글 시스템인 utternaces로 변경한 내용을 정리합니다. OGP API 서버 Heroku에 배포하기 이 문서는 블로그에서 외부 게시글에 대한 미리보기를 작성하면서 Open Graph를 적용하는 방법을 정리한 것입니다. Hugo나 Hexo를 기준으로 적용하는데 필요한 OGP 처리용 API Server를 구성하는 내용이므로 OGP에 대한 상세한 내용은 아래의 참고 자료를 활용하시기 바랍니다.\n "
}]