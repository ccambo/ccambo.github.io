[
{
	"uri": "/Cloud/Concepts/edge-computing/",
	"title": "Edge Computing",
	"tags": ["Edge Computing"],
	"description": "Edge Computing에 대한 내용을 정리합니다.",
	"content": " 엣지 컴퓨팅이란? 클라우드 컴퓨팅이란 인터넷을 통해 서버, 저장소, 소프트웨어, 분석 등의 컴퓨팅 서비스를 제공하는 것을 말한다. 이미 많은 기업들이 클라우드 환경으로 전환했으며, 이 과정에서 여러 가지 문제점들이 발생하게 된다.\n 사용자의 폭발적인 증가로 인해 서버 및 데이터 센터에서 처리할 수 있는 데이터 양을 넘어서기 시작하면서 데이터 처리 속도 문제 데이터의 송/수신 과정의 지연 현상 발생 (Latency) 통신 과정 상의 보안 문제  이런 문제점들을 해결하기 위해서 \u0026ldquo;사용자의 단말 또는 가까운 위치에서 컴퓨팅을 수행\u0026rdquo;하는 방식의 엣지 컴퓨팅 개념이 탄생했다.\n데이터를 데이터 센터로 전송하고 데이터를 처리하는 방식의 클라우드 컴퓨팅과는 달리 엣지 검퓨팅은 스마트폰과 같은 단말(엣지) 기기 또는 가까운 위치에서 데이터를 처리하는 분산 개방형 아키텍처를 말하며 이를 기반으로 모바일 컴퓨팅 및 IoT (Internet of Things) 기술을 활용할 수 있다.\n [출처 : 삼성 뉴스룸 - 엣지컴퓨팅]   [출처 : 위키백과]  엣지 컴퓨팅이 필요한 이유 클라우드 컴퓨팅에서는 발생한 데이터를 클라우드로 전송하고 데이터를 가공하고 결과를 받는 형식이지만 엣지 컴퓨팅에서는 사용자 또는 데이터 소스의 물리적인 위치나 그 위치와 가까운 곳에서 컴퓨팅이 수행되기 때문에 사용자는 더욱 빠르고 안정적인 서비스를 제공받을 수 있으며, 기업은 유연한 하이브리드 클라우드 컴퓨팅의 이점을 얻을 수 있다. 따라서 엣지 컴퓨팅을 활용하면 기업이 다수의 위치에서 공통의 리소스 풀을 사용해서 데이터 연산 및 처리를 분산시킬 수 있는 방법으로 구축이 가능하게 된다.\n 데이터 부하 감소 클라우드 컴퓨팅에서는 모든 발생 데이터가 취합되고 처리되기 때문에 데이터 양에 따른 부하가 생기지만, 엣지 컴퓨팅은 해당 단말 또는 해당 지역에서 발생하는 데이터로 한정되어 처리하므로 부하를 줄일 수 있다. 보안 클라우드 컴퓨팅은 클라우드로 데이터를 전송/전달 단계부터 보안에 대한 요구가 존재하게 되지만, 엣지 컴퓨팅은 데이터 수집과 처리를 해당 단말 또는 가까운 지역에서 처리하므로 상대적으로 보안이 좋다 장애 대응 클라우드 컴퓨팅은 클라우드 장애가 발생하면 치명적이지만, 엣지 컴퓨팅은 자체적으로 컴퓨팅을 수행하기 때문에 효과적으로 대응이 가능하다.  엣지 컴퓨팅 사례  가상/증강 현실 : 종종 대역폭 부족과 긴 지연 시간의 문제가 발생한다. 이로 인해서 몰입이 방해되는 경우가 많기 때문에 엣지 컴퓨팅을 활용해서 렌더링 파이프라인의 컴퓨터 집약적인 부분을 클라우드로 이전하여 이런 문제를 해결할 수 있다. 스마트 카/스마트팩토리 : 길 안내를 하고 있는 상황에서의 데이터 처리 지연은 악몽이 된다. 따라서 자동차 또는 IoT 기기가 엣지 컴퓨팅을 활용해서 실시간 데이터를 처리하고 결정을 내릴 수 있도록 할 수 있다. 보안 및 GDPR(규제 정책) : 엣지 컴퓨팅을 활용해서 컴퓨팅 기능 (데이터 수집과 처리 등)을 로컬 네트워크에서 수행함으로써 민감한 데이터의 유출이 완화되므로 기업들이 정보(영업 비밀 등)의 확산을 효과적으로 통제하고 규제 정책(GDPR 등)을 준수 할 수 있다. 장애 대응 : 엣지 컴퓨팅을 활용해서 클라우드 컴퓨팅 대비 복구 능력과 비용 절감 효과를 누릴 수 있으며, 주요 기능이 로컬 네트워크에서 수행되기 때문에 클라우드가 어떤 이유로 장애가 발생해도 지역 사이트는 독립적으로 계속 운영이 가능하고, 클라우드와 지역 사이트 간의 데이터를 교류하기 위해 소비되는 대역폭 비용도 크게 절감이 가능하다.  엣지 컴퓨팅의 이점  클라우드 컴퓨팅은 몇몇의 대규모 데이터 센터로 서비스를 중앙 집중화하는데 초점에 맞춰져있고 이를 통해서 제어 능력과 기업 보안을 유지하면서도 리소스의 확장성을 높이고 보다 효율적인 공유가 가능하다. 반면에 엣지 컴퓨팅은 주로 네트워크 요구사항 또는 기타 제약으로 클라우드 컴퓨팅의 중앙집중식 접근방식으로 적절하게 해결할 수 없는 활용 사례를 처리한다. 여러 소규모의 컴퓨팅 사이트에 중점을 두고 네트워크 비용을 절감하고 대역폭 제한을 피하며, 전송 지연과 서비스 장애를 줄이고, 민감한 데이터의 이동을 더욱 효과적으로 제어할 수 있다. 어플리케이션의 로드 시간을 단축하고 사용자 가까이에서 배포되는 온라인 서비스를 통해서 동적 및 정적 캐시 기능을 모두 지원할 수 있으므로 최종 사용자에게 더욱 빠르고 일관성있는 사용자 환경을 제공할 수 있다. 기업과 서비스 제공업체는 실시간 모니터링이 가능하며, 지연 시간이 짧고 가용성이 높은 어플리케이션 구현이 가능하다.  엣지 컴퓨팅의 과제 가장 큰 문제점은 고도로 분산된 환경에서 규모를 확장하는 상황에서 발생한다.\n 클라우드 컴퓨팅의 중앙집중적 시스템에서는 스케일 아웃하는 것이 상대적으로 쉽지만, 많은 소규모 사이트가 연계되는 엣지 컴퓨팅에서는 훨씬 복잡하며, 물리적인 위치에 따른 오버헤드가 증가하여 소규모 기업에서 관리하기에는 부담이 될 수 있다. 소규모 사이트는 전문 기술자가 없거나 제한적인 원격지일 가능성이 높기 때문에 장애가 발생하는 경우 비기술 현장 인력이 해결하고 다른 지역의 전문 인력이 중앙에서 관리할 수 있도록 인프라를 구축해야 한다. 각 사이트 관리 작업은 모든 사이트에서 적용 가능하도록 간단해야 하며, 문제 해결을 지원해야 하고, 각 사이트에서 소프트웨어 설정이 다른 방식으로 구현되는 것을 방지할 수 있어야 한다. 데이터를 지리적으로 제한하여 정보의 흐름을 효과적으로 운영할 수는 있지만, 각 사이트에 대한 물리적인 보안은 취약할 수 밖에는 없기 때문에 악의적인 공격이나 우발적인 손상으로 인한 문제 발생 위험은 오히려 더 높을 수 있다.  참고자료  엣지 컴퓨팅? 엣지 컴퓨팅  "
},
{
	"uri": "/Git/Tips/how-to-change-users/",
	"title": "How to Change Users",
	"tags": ["Git", "Change Users"],
	"description": "Git 사용 중에 사용자 변경 관련 오류를 해결하는 방법을 정리합니다.",
	"content": " 대부분의 경우는 단일 사용자로 Git를 운영하겠지만 다양한 이유에 의해서 Git 사용자를 변경해야 하는 상황이 존재한다.\n여기서는 이런 문제를 해결하는 방법에 대해서 알아본다.\n발생 상황 git 설치 후에 기본 환경 설정을 했을 것이다.\n# 전역 설정인 경우 $ git config --global user.name \u0026#34;user name\u0026#34; $ git config --global user.email \u0026#34;user email\u0026#34; # git 단위 설정인 경우 $ git config user.name \u0026#34;user name\u0026#34; $ git config user.email \u0026#34;user email\u0026#34; 이런 상황에서 지정한 사용자로 Git에 로그인 한 후에 다른 사용자를 사용해서 push를 하면 다음과 같은 오류가 발생하게 된다.\n$ git push origin master # terminal에서 실행한 것과 VSCode와 같은 IDE에 연동한 경우도 동일한 상황이 발생한다. remote: Permission [git_url.git] denied to [user_id] fatal: unable to acess `[git_url]`: The requested URL returned error: 403 ... 오류 메시지 내용은 해당 사용자로 remote repository에 push할 권한이 없다는 것이다.\n해결 방법 구글을 검색해 보면 대부분 아래와 같은 해법을 제시한다.\n 사용할 git 프로젝트에서 config 설정을 사용자에 맞도록 변경하면 된다.\n$ git config user.name \u0026#34;new user name\u0026#34; $ git config user.email \u0026#34;new user email\u0026#34; 권장하는 방식으로 해 봐도 동일한 오류가 발생한다. (당연히 이미 로그인 사용자 정보를 기준으로 하므로 설정을 바꾼다고 해서 로그인 정보가 변경되지는 않는다)\n ssh 키 관련해서 여러 가지 처리를 제시하는 것도 있지만, 제대로 안되는 상황이 발생한다.\n  환경 설정을 바꿨기 때문에 지금 push 하려는 사용자와 로그인 사용자가 달라졌으므로 로그인을 다시 물어봐야 할 것 같은데, 실제로는 로그인을 다시 물어보지 않는다.\n의외로 쉽게 해결하는 방법은 다음과 같다.\n Mac 환경  Spotlight 검색 등으로 키 체인 접근 앱을 실행한다.  키 체인 접근 앱에서 로그인을 선택하고 github.com을 찾아서 더블클릭한다.  로그인 정보 창에서 계정과 암호를 변경하고 저장한다.   Windows 환경  제어판 \u0026gt; 사용자 계정 \u0026gt; 자격 증명 관리자를 실행한다. windows 자격 증명 항목의 github 관련 정보를 수정한다. 위와 같이 설정한 후에 다시 push를 실행하면 잘 처리가 된다.   결론 오류의 원인이 로그인된 사용자 정보를 그대로 사용하려고 하는 것이기 때문에 터미널을 사용하던 VSCode와 같이 IDE에 연동해서 사용하던 이미 사용했던 로그인 정보를 삭제 또는 변경해서 로그인을 다시하면 쉽게 해결이 가능하다.\n"
},
{
	"uri": "/Git/Submdule/what-is-the-submodule/",
	"title": "What is the submodule",
	"tags": ["Git", "Submodule"],
	"description": "Git의 Submodule에 관련된 내용을 정리합니다.",
	"content": " 아래의 내용은 정리하면서 검증한 부분도 있지만, 검증이 되지 않고 정리된 내용도 있을 수 있으므로, 반드시 관련된 정보를 추가로 검색하여 검증해야 한다.\n Submodule? Git 프로젝트는 하나의 독립된 라이브러리라고 생각할 수 있다. 따라서 특정 프로젝트를 진행할 때 또 다른 프로젝트를 내부적으로 사용해야하는 경우가 빈번하게 발생할 수 있다. 일반적으로 이런 상황에서는 필요한 라이브러리의 특정 버전을 설치하거나 소스를 복사해서 사용하는 방법을 사용하는데 이에 따른 버전관리나 소스의 변경등에 대한 대처가 만만치 않다.\nGit와 Submodule을 사용하면 Git Repository 내에 또 다른 독립적인 Repository를 운영하는 구조를 만들 수 있다. 당연히 각 Repository는 독립적으로 관리된다.\n이런 상황이 새로운 것일까? Node 환경이라면 이미 npm을 이용해서 package를 관리하며 사용하고 있다. 그런데 가져다 쓸 패키지가 git에 repository로만 존재하는 경우라면 어떻게 해야할 까? 이런 상황에 대체하기 위한 것이 submodule이고 정리하면 submodule은 git repository 하위에 다른 git repository를 관리하기 위한 도구라고 생각하면 된다. 자세한 내용은 Pro Git의 내용을 참고!\n 사용법 정리 기본 옵션들 git submodule에 대한 공식 옵션은 다음의 명령으로 확인 가능하다.\n$ git submodule --help main project와 submodule project 관계 main project에 submodule을 추가하면 submodule들을 관리하기 위한 .gitmodules파일이 생성되고 여기에 submoudle에 대한 폴더와 repository 정보가 관리되며 main project는 추가된 submodule에 대한 commit point를 바라보고 있게 된다.\n따라서 main project와 submodule 간의 처리는 아래와 같은 순서에 주의해야 한다.\n clone / pull / update : 리모트에서 로컬로 데이터를 가져올 경우는 Parent 먼저 처리 후 submodule을 처리해야 한다. commit / push : 로컬 commit과 리모트로 데이터를 전송하는 경우는 submodule 먼저 처리 후 Parent를 처리해야 한다.  main project가 submodule에 대한 commit point를 연계하고 있기 떄문에 위의 순서가 맞지 않으면 잘못된 submodule의 commit point를 바라보게 되므로 문제가 발생할 수 있다.\n submodule 추가 # main project의 root 폴더에서 실행 $ git submodule add [-b branch_name] \u0026lt;repository address\u0026gt; [path] # path를 생략하면 현재 경로 밑으로 repository 이름으로 생성된다. 정상적으로 추가되면 main project 경로에 .gitmodules 파일이 생성되며, 내용은 아래와 같이 구성된다.\n[submodule \u0026#34;themes/hugo-theme-docdock\u0026#34;] path = themes/hugo-theme-docdock url = https://github.com/vjeantet/hugo-theme-docdock.git 위와 같이 Root Repository (여기서는 Hugo로 만든 사이트) 를 기준으로 경로와 git repository url이 관리되고 있는 것을 확인할 수 있다.\nsubmodule이 추가된 것은 main project가 변경된 것을 의미하기 때문에 commit을 수행해 줘야 한다. 특정 branch로 지정할 경우는 -b \u0026lt;branch name\u0026gt;을 사용하면 된다. 또한 나중에 submodule에 대한 branch를 설정할 경우는 아래와 같이 처리할 수도 있다.\n# main project root 폴더에서 실행 $ git config -f .gitmodules submodule.\u0026lt;submodule path\u0026gt;.branch \u0026lt;branch name\u0026gt; submodule 상태 확인 기본적인 git 상태 확인은 아래의 명령을 사용하며 submodule과 연동해서 사용할 수 있다.\n# main project root 폴더에서 실행 # main project 상태 확인 $ git status # submodule 상태 확인 $ git submodule status # main project 상태확인에 submodule 정보 추가해서 보기 설정 $ git config status.submodulesummary 1 main project에서 바라보는 submodule 상태 # main project root 폴더에서 실행 $ git diff --cached \u0026lt;submodule path\u0026gt; new file mode 160000 index 0000000..51dbdcf --- /dev/null +++ b/themes/hugo-theme-learn @@ -0,0 +1 @@ +Subproject commit 51dbdcf4aaef01d02e78a6ea76b2a6fde5842b55 위의 내용을 검토해 보면 다음과 같은 특징이 존재한다.\n mode 160000은 일반적인 파일이나 디렉토리가 아니라는 의미를 가진다. Subproject commit 51dbdcf4aaef01d02e78a6ea76b2a6fde5842b55는 main project가 submodule repository의 51dbdcf4aaef01d02e78a6ea76b2a6fde5842b55 commit 정보를 바라보고 있다는 의미를 가진다.  Detached HEAD 문제 Detached HEAD 문제란 submodule update 명령이 수행되면 해당 submodule이 어떤 branch에도 속하지 않는 분리된 HEAD 정보를 가지는 상태를 말하는 것으로 branch를 지정해 줘야 한다. 따라서 아래와 같이 각 단계별 명령을 수행할 때 지정해 주는 것이 좋다.\n# main project root 폴더에서 실행 # 처음 clone할 때 $ git submodule init $ git submodule udpate $ git submodule foreach git checkout \u0026lt;branch name\u0026gt; # pull/update할 때 $ git pull $ git submodule update --remote --merge # push할 때 $ git push --recurse-submodules=check git detached HEAD에 대한 내용은 정보를 참고하고, submodule과 detached HEAD에 대한 내용은 정보를 참고하면 된다.\n 단축 명령 및 Config 설정 위에서 알아본 명령들을 별칭(Alias) 등록을 통해서 단축 명령으로 수행할 수도 있다.\n# git sdiff 단축 정의 $ git config alias.sdiff \u0026#39;!\u0026#39;\u0026#34;git diff \u0026amp;\u0026amp; submodule foreach \u0026#39;git diff\u0026#39;\u0026#34; # git spush 단축 정의 $ git config alias.spush \u0026#39;push --recurse-submodules=check\u0026#39; # git supdate 단축 정의 $ git config alias.supdate \u0026#39;submodule update --remote --merge\u0026#39; main project에 아래와 같이 정보를 설정해 두면 활용하기 쉽다.\n# login $ git config credential.helper cache # status $ git config status.submodulesummary 1 # diff $ git config diff.submodule log 이미 submodule을 포함하고 있는 Repository 활용하기 clone and update submodules  Parent git project clone : .gitmodules 파일이 존재하며, 파일내에 어떤 폴더에 어떤 git repository를 사용하는지에 대한 정보를 알 수 있다.\n$ git clone \u0026lt;main project repository\u0026gt; submodule clone\n# clone된 main project root 폴더에서 실행 $ git submodule init # submodule 초기화 $ git submodule update # submodule 갱신(다운로드 - Detached HEAD 상태로 어떤 branch에도 속하지 않는 상태) $ git submodule foreach git checkout \u0026lt;branch name\u0026gt; # 지정한 branch로 설정  위의 clone 과정을 한번에 처리할 수도 있다. $ git clone \u0026ndash;recurse-submodules \u0026lt;main project repository\u0026gt; $ git submodule foreach git checkout \n 이미 로컬에 submodule이 존재하는 경우 갱신 $ git submodule update --remote --merge commit and push submodules  만일 새로운 branch로 작업하는 경우\n$ git submodule foreach git checkout -b \u0026lt;feature name\u0026gt; 변경된 코드들 commit\n$ git submodule foreach git add -A . $ git submodule foreach git commit -am \u0026#34;commit message\u0026#34; $ git submodule foreach git checkout \u0026lt;branch name\u0026gt; $ git submodule foreach git merge \u0026lt;feature name\u0026gt; push submodules\n$ git submodule foreach git push commit and push main project\n$ git commit -am \u0026#34;commit message\u0026#34; $ git push --recurse-submodules=check  위에서 언급한 것과 같이 push를 할 때는 반드시 submodule들을 먼저 처리하고 main project를 처리해야 한다. 따라서 submodule들이 모두 push되었는지를 확인해야 한다.\n# main project push 전에 root 폴더에서 $ git push --recurse-submodules=check # submodule들이 모두 push된 상태인지를 검사하고 확인되면 push 처리 $ git push --recurse-submodules=on-demand # submodule들을 모두 push하고 성공하면 push 처리 매번 명령어를 지정해서 처리하는 것을 항상 처리할 수 있도록 하는 것은 설정으로 처리해 두면 된다.\n$ git config push.recurseSubmodules check $ git config push.recurseSubmodules on-demand submodule 제거  .gitmodules 파일에서 대상 submodule 정보를 삭제한다. 변경된 내용을 stage 처리 한다.\n$ git add .gitmodules .git/config 파일에서 대상 submodule 정보를 삭제한다.\n git 에서 cached 인덱스 정보를 제거한다.\n$ git rm --cached \u0026lt;path to submodule\u0026gt; # 맨 뒤의 \u0026#39;/\u0026#39;는 사용하지 않는다. ./git/modules 폴더에서 대상 submodule 폴더 정보를 삭제한다.\n$ rm .git/modules/\u0026lt;path to submodule\u0026gt; # 맨 뒤의 \u0026#39;/\u0026#39;는 사용하지 않는다. 변경된 내용을 commit 한다.\n 제거된 submodule 폴더를 삭제한다.\n$ rm -rf \u0026lt;path to submodule\u0026gt;  위의 내용은 기본적인 git 명령을 사용한 것이고 submodule 명령을 통하면 다음과 같이 더 간단하게 처리가 가능할 수 있다.\n git에서 submodule 관련 정보 삭제\n$ git submodule deinit \u0026lt;path to submodule\u0026gt; git에서 submodule 삭제\n$ git rm \u0026lt;path to submodule\u0026gt; 변경 내용 commit\n submodule 폴더 삭제\n$ rm -rf ./git/modules/\u0026lt;path to submodule\u0026gt;  참고자료  git-scm Book Chapter 6. Git Tools - Submodule How to effectively delete a git submodule  "
},
{
	"uri": "/Git/Basics/",
	"title": "Basics",
	"tags": [],
	"description": "",
	"content": " Basics 이 문서에서는 Git 사용에 필요한 기본적인 정보들을 정리하고 있습니다.\n"
},
{
	"uri": "/Cloud/Concepts/",
	"title": "Concepts",
	"tags": [],
	"description": "",
	"content": " Concepts Cloud와 연계되는 개념들을 정리합니다.\n"
},
{
	"uri": "/Git/",
	"title": "Git",
	"tags": [],
	"description": "",
	"content": " Git 관련 정보들 정리 이 문서에서는 Git 사용에 필요한 정보들을 정리하고 있습니다.\n"
},
{
	"uri": "/Cloud/",
	"title": "Cloud",
	"tags": [],
	"description": "",
	"content": " Cloud 이 문서에서는 Cloud에 필요한 정보들을 정리하고 있습니다.\n"
},
{
	"uri": "/Git/Submdule/",
	"title": "Submodule",
	"tags": [],
	"description": "",
	"content": " Submodule 이 문서에서는 Git의 Submodule에 관련된 정보들을 정리하고 있습니다.\n"
},
{
	"uri": "/Dev/",
	"title": "Dev",
	"tags": [],
	"description": "",
	"content": " Developments 이 문서에서는 개발에 필요한 정보들을 정리하고 있습니다.\n"
},
{
	"uri": "/FunnyLab/",
	"title": "FunnyLab",
	"tags": [],
	"description": "",
	"content": " Funny Lab 엉뚱하고 재미있는 상상들을 정리하고 있습니다.\n"
},
{
	"uri": "/Cloud/Docker/",
	"title": "Docker",
	"tags": [],
	"description": "이 페이지는 Docker에 대한 관련된 정보들을 정리합니다.",
	"content": " Docker 관련 정보들 정리!!! "
},
{
	"uri": "/Cloud/Kubernetes/",
	"title": "Kubernetes",
	"tags": [],
	"description": "이 페이지는 Kubernetes에 관련된 정보를 정리합니다.",
	"content": " Kubernetes 관련 정보 정리!!! "
},
{
	"uri": "/Cloud/Docker/Tips/",
	"title": "Tips",
	"tags": [],
	"description": "Docker 사용 중에 발생한 오류들의 해결방법이나 유용한 정보들을 정리합니다.",
	"content": " Errors and Tips "
},
{
	"uri": "/Git/Tips/",
	"title": "Tips",
	"tags": [],
	"description": "",
	"content": " Tips 이 문서에서는 Git 사용 중에 발생한 오류들의 해결 방법이나 유용한 정보들을 정리하고 있습니다.\n"
},
{
	"uri": "/",
	"title": "MSFL",
	"tags": [],
	"description": "",
	"content": " 지식 저장소 여러 가지 정보들을 하나의 지식 저장소처럼 꾸미는 꿈을 가지고 진행하고 있습니다.\n"
},
{
	"uri": "/Dev/UI-Framework/",
	"title": "",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/Dev/UI-Framework/Vue/",
	"title": "",
	"tags": [],
	"description": "",
	"content": ""
}]