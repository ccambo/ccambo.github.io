[
{
	"uri": "http://ccambo.github.io/FunnyLab/Blogging/change-comments-to-utterances/",
	"title": "댓글 시스템 utterances로 변경",
	"tags": ["Disqus", "utterances", "blog comments"],
	"description": "기존 Disqus 댓글 시스템의 문제점으로 Github연동형 댓글 시스템인 utternaces로 변경한 내용을 정리합니다.",
	"content": " 댓글 시스템 변경 기존에 사용하던 Disqus에 딱히 큰 문제가 있었던 것은 아니다.\n Disqus의 댓글 데이터들을 사이트들에 행동패턴등의 Big data 용도로 판매가 이뤄지고 있는 것 같다는 의심들 (차단 또는 정보공유 비활성 설정등으로 가능할 것 같다) Basic Plan인 경우는 Disqus 광고가 많은 자리를 차지한다는 것 (Ads 옵션 조정으로 광고갯수 조정 또는 유료 플랜 사용)  그러나 귀차니즘에 다른 댓글 시스템을 찾아보다가 utterances라는 github issus처럼 댓글을 관리할 수 있는 방법을 발견해서 테스트 겸 변경했다.\n Github Issue 기반이므로 (Repository 운영) 블로그 플랫폼을 변경해도 기존 Comment를 그대로 사용할 수 있다. 개발과 관련된 블로그이므로 Github 계정으로 댓글을 작성할 수 있다. 많은 블로그들이 이미 이 댓글 시스템을 사용하고 있는 것 같다.  적용하기 Utterances 사이트로 이동하면 간단하게 적용할 수 있도록 문서로 설명되어 있다. 간단히 처리를 정리하면 다음과 같다.\n github에 댓글 관리를 위한 Repository 생성 (공개형) 생성한 Repository에 utterances App 설치 utterances 사이트에 repo 정보를 \u0026ldquo;owner/repo\u0026rdquo;  형식으로 입력 \u0026ldquo;Blog Post ↔️ Issue Mapping\u0026rdquo; 항목을 자신의 블로그 플랫폼에 맞도록 선택 (이슈 제목을 블로그 경로로할지? 페이지 제목으로 할지? 임의로 지정한 값으로 할지? 등) utterances에서 생성한 이슈에 대한 라벨 설정 테마 선택  이렇게 설정하고 스크립트 태그를 블로그의 댓글 처리할 곳에 지정하면 된다.\n실제로 utterances 사이트에 정보를 입력해서 스크립트 코드를 생성해서 사용해도 되지만 그냥 스크립트만을 복사해서 내용을 원하는 (위에서 설정한 것과 같이) 데로 변경한 다음 사용해도 된다. 단, 반드시 github에 utterances.app를 먼저 설치하고 진행해야 한다. 미 설치시 댓글시스템은 동작을 하지만 포스트와 연결되지는 않는다. \n 지금 보고 있는 이 글의 댓글은 utterances를 스트립트만 변경해서 적용한 것이다.\n참고자료  Utterance  "
},
{
	"uri": "http://ccambo.github.io/Dev/Vue/intro_key_of_vue/",
	"title": "Vue 키 포인트 소개",
	"tags": ["Vue"],
	"description": "프로젝트에 Vue를 도입한 결정적인 이유",
	"content": " 프로젝트에서 사용할 Front-End Framework을 고심하던 중에 Gregg이 Vue.js를 소개하는 공식 자료를 보고 Vue를 선택했다. 아래의 내용은 참고자료에 언급한 원문을 번역하면서 나름대로 정리한 것으로 왜 Vue가 43%의 개발자들이 vue.js를 배우려고 하는지를 알 수 있다.\n현재 TOP 3 (Angular, React, Vue)의 자바스크립트들에 대한 비교는 vue.js 공식문서를 참고하면 된다.\n 점진적인 프레임워크 Vue는 진입장벽이 낮고, 유연하고, 성능이 우수하고, 유지보수와 테스트가 편한 자바스크립트 프레임워크로 점진적인 프레임워크를 지향  하고 있다. 점진적인 프레임워크라는 것은 웹 어플리케이션 전체를 한꺼번에 하나의 프레임워크 구조로 구조화하지 않아도 일정 부분만 적용 가능  해서 사용자에게 더 좋은 사용자 경험을 제공할 수 있다는 것을 의미한다. 물론 전체를 처음부터 Vue로 구현할 수도 있다. Vue가 큰 규모의 어플리케이션을 개발할 수 있도록 핵심 라이브러리와 주변 생태계를 제공하고 있다.\n[출처:Vuejs - 점진적인 프레임워크]  재 사용 가능한 컴포넌트 (단일 파일 컴포넌트) 다른 프레임워크들처럼 재 사용이 가능한 컴포넌트로 웹 페이지를 구성할 수 있으며, 각 컴포넌트는 페이지 영역을 표시하는데 필요한 HTML, CSS, Script 를 가지는 단일 파일 컴포넌트 구조를 제공한다.\n[출처:Vuejs - 컴포넌트로 페이지 구성]  프로젝트로 알아보기 아주 간략하고 특징적인 Vue의 주요 컨셉을 알아볼 수 있다.\n대 부분의 자바스크립트와 같이 페이지에 데이터를 표시하는 것부터 시작한다.\n[출처:Vuejs - 페이지에 데이터 표시]  위의 그림에 표시된 것과 같이 \u0026ldquo;X\u0026rdquo;의 위치에 스크립트에서 설정한 \u0026ldquo;Boots\u0026rdquo;를 표시하고 싶으면 아래와 같이 구현하면 된다.\n[출처:Vuejs - Vue로 페이지에 데이터 표시]  위의 내용을 좀 더 자세히 확인하면 다음과 같다.\n 정보를 표시할는 것은 Vue의 데이터를 바인딩할 때 사용하는 \u0026ldquo;{{ ... }}\u0026rdquo; 를 사용한다. 위의 예는 Vue 에서 관리하는 데이터 중에서 \u0026ldquo;product\u0026rdquo;라는 정보를 출력한다는 의미다. 물론 아직 데이터는 없다. \u0026lt;script\u0026gt;...\u0026lt;/script\u0026gt; 로 Vue 라이브러리를 포함시키고 구동 가능한 상태로 만든다. const app = new Vue({ ... }) 코드로 Vue 인스턴스를 생성한다. Vue 인스턴스를 생성할 떄 동작에 필요한 옵션을 지정한다.  el : Vue 인스턴스가 DOM과 연계될 수 있도록 대상 엘리먼트를 지정한다. data : Vue 동작에 필요한 데이터를 JSON 형식으로 지정한다.   위의 코드를 실행하면 아래와 같이 결과를 확인할 수 있다.\n[출처:Vuejs - 정적 데이터 표시]  위의 결과까지는 일반적인 수준이지만 정적이 아닌 동적으로 데이터가 변경될 때 Vue의 마법을 경험할 수 있다. 아래와 같이 개발자 도구의 콘솔에서 데이터를 변경하면 어떻게 데이터가 연동되는지를 확인할 수 있다.\n[출처:Vuejs - 동적 데이터 표시]  위의 결과에서 알 수 있듯이 Vue는 데이터가 변경되면 Vue에서 알아서 변경된 내용을 처리하는 방식을 제공한다. 이 동작은 문자열뿐만 아니라 모든 유형의 데이터에 모두 적용된다. 이를 확인해 보기 위해서 위의 샘플 코드를 배열을 처리할 수 있도록 \u0026quot;ul\u0026quot; 태그와 \u0026quot;li\u0026quot; 태그 구조로 변경한다. 이때 템플릿처럼 구성하는 것이기 때문에 v-for라는 특별한 속성을 지정 (foreach 문장구조와 비슷)  해야 한다. 그리고 Vue 인스턴스 생성할 떄의 data 부분을 배열구조인 products로 변경한다.\n[출처:Vuejs - 동적 데이터 표시 (v-for 지시자 사용)]  변경된 코드를 브라우저에서 실행해 보면 아래와 같은 결과를 확인할 수 있다.\n[출처:Vuejs - 동적 데이터 표시 결과]  좀 더 확장을 해서 서버를 호출해서 데이터를 받아온 결과를 기준으로 화면에 동적으로 출력하는 것으로 가정하면 아래와 같이 코드를 구성하면 된다.\n[출처:Vuejs - 동적 데이터 표시 (API 호출))]  위의 코드를 살펴보면 다음과 같은 변화가 있다.\n data를 products라는 빈 배열로 초기화만 처리한다. created 라는 vue 인스턴스의 생성시점에 호출되는 이벤트를 사용해서 API 호출 코드를 작성한다.  fetch 메서드를 통해서 API를 호출한다. then 메서드를 이용해서 API 호출 결과를 Vue에서 관리하는 데이터로 변환해서 설정한다.   위의 코드에서 호출된 API의 결과는 JSON형식으로 실행된 화면은 아래와 같이 표시된다.\n[출처:Vuejs - 동적 데이터 표시 (API 호출 결과))]  API에서 반환된 JSON을 그대로 출력한 것이기 떄문에 이를 좀 더 사용자에게 친숙한 형식으로 처리하기 위해서 아래와 같이 View 처리를 변경한다.\n[출처:Vuejs - v-for 지시자 표현식)]  수행된 결과는 반환된 결과에서 product.quantity와 product.name 만을 출력하는 것으로 변경했기 때문에 아래와 같이 나타난다.\n[출처:Vuejs - v-for 지시자 표현식 결과)]  각 데이터 항목중에서 갯수가 0인게 있으면 사용자가 좀 더 잘 인식할 수 있도록 \u0026ldquo;\u0026lt;span\u0026gt;\u0026rdquo; 태그를 사용해서 item.quantity === 0 일 때만 \u0026ldquo;OUT OF STOCK\u0026rdquo; 텍스트가 보이도록 아래와 같이 변경한다.\n[출처:Vuejs - v-for 지시자 표현식)]  위의 표현식에서는 v-if 지시자를 이용해서 조건식을 구성해서 재고 여부를 좀 더 확실하게 구분할 수 있도록 변경했다.\n[출처:Vuejs - v-if 지시자 표현식)]  이제 모든 상품의 총 재고량을 목록 아래쪽에 표시하려면 totalProducts라는 computed 속성을 활용하면 된다. 만일 자바스크립트의 reduce() API가 익숙하지 않다면 그냥 재고 총합을 구하는 동작이라고 이해하면 된다.\n[출처:Vuejs - computed 속성)]  실행을 해 보면 아래와 같이 모든 상품의 총 재고량이 계산되어 표시된다.\n[출처:Vuejs - computed 속성 결과)]  Vue 개발자 도구(Vue.js Chrome Extension)의 장점 중에 하나는 페이지상에 표시된 데이터를 살펴볼 수 있다는 점이다.\n[출처:Vuejs - Vue Dev Tools)]  앞에서 보았던 데이터의 변화가 View에 동적으로 표현되는 부분을 다시 한번 확인할 겸해서 개발자 도구의 콘솔에서 2개의 product를 제거해 보면 아래와 같이 리스트뿐만 아니라 총 재고량도 변경되는 것을 확인할 수 있다.\n[출처:Vuejs - Vue Dev Tools에서 데이터 변경 결과]  이번에는 버튼을 사용해서 페이지에 이벤트를 추가하고 버튼을 눌렀을 때 각 상품의 재고량을 1개씩 늘리는 것으로 변경해 보도록 한다.\n[출처:Vuejs - v-on click 이벤트)]  실행해 보면 Add 버튼을 눌렀을 때 각 상품의 재고와 총 재고량의 숫자를 증가시키는 것과 Jacket 상품에서는 OUT OF STOCK 글씨도 사라지는 것을 확인할 수 있다.\n[출처:Vuejs - v-on click 이벤트 결과)]  좀 더 확장해서 재고량을 직접 입력할 수 있도록 input 박스를 추가하고 v-model 지시자를 연결하고 입력되는 값은 항상 숫자인 것으로 지정하도록 변경한다.\n[출처:Vuejs - v-model 지시자)]  위의 input 박스에는 양방향 바인딩을 위한 v-model 지시자를 이용해서 숫자인 데이터를 Vue에서 관리하고 있는 데이터 항목에 연동하는 설정을 한 것이다.\n이제 버튼을 통한 것뿐만 아니라 사용자가 직접 숫자를 입력해서 재고를 변경할 수도 있다. 물론 0으로 숫자를 설정하는 OUT OF STOCK이 표시되는 것도, Add 버튼 처리도 모두 잘 동작하는 것을 확인할 수 있다.\n[출처:Vuejs - v-model 지시자 결과)]  지금까지 설명하고 실행해서 검증했던 소스는 JSFIDDLE에서 확인할 수 있다.\n추가적인 Vue 특징  규모가 있는 어플리케이션을 구축한다면 여러 개의 컴포넌트를 조합해야 한다.  [출처:Vuejs - Single file components)] \n Vue는 CLI (Command Line Interface) 명령어 도구를 이용해서 쉽게 프로젝트를 생성할 수 있다. 아래의 명령으로 프로젝트를 시작하면 된다. [출처:Vuejs - Vue-cli)] \n 컴포넌트 별로 .vue 파일을 생성해서 관리할 수 있고, 각 .vue 파일에는 HTML, Javascript, CSS \u0026amp; SCSS 가 들어간다. (Single file component) [출처:Vuejs - Vue Component System)] \n  결론 지금까지 Vue가 할 수 있는 기능들 중에서 아주 기초적인 일부만 확인해 봤다. Vue에는 프론트엔드 화면을 개발하고, 구성하고, 빌드하기 위한 더 많은 기능들이 존재한다. 만일 Vue를 배우고 싶다면 아래의 2가지 자료를 추천한다.\n VueMastery의 Vue Guide \u0026amp; CheatSheet : 무료 소개 과정과 계정을 만들면 CheatSheet를 받을 수 있다. Vue.js 공식 문서  참고자료  Why 43% of Front-End Developers want to learn Vue.js  "
},
{
	"uri": "http://ccambo.github.io/Dev/Web/npm_vs_yarn/",
	"title": "NPM vs YARN",
	"tags": ["npm", "yarn"],
	"description": "npm과 yarn에 대한 비교",
	"content": " node + npm이 기본이었는데, 몇 가지 npm의 문제점을 해결하기 위해 yarn이 발표되었다.\n기존 NPM은 배포가 쉽고, 종속성을 쉽게 해결할 수 있지만 패키지가 중복으로 설치될 수 있고, 파일이 많은 경우에 문제가 될 수 있다. 페이스북에서는 이런 문제점들을 해결하기 위해서 yarn을 발표했다.\n npm3 보다 패키지 설치 속도가 빠르다. json 포맷을 사용하지 않는다. offline 모드가 가능하다.  YARN 설치  설치페이지를 통해서 직접 설치가 가능하다. 맥북이라면 brew를 이용해서 설치가 가능하다. npm을 통해서도 설치가 가능하다.  터미널에서의 설치는 다음의 명령으로 처리하면 된다.\n Yarn 설치 명령  $ npm install -g yarn # npm 사용 $ brew install yarn # 맥북   명령 비교 NPM과 YARN 기본 명령들 비교   npm 명령 yarn 명령 설명     npm init yarn init 프로젝트 초기화   npm install yarn or yarn install package.json 의 패키지 설치   npm install \u0026ndash;save [package name] yarn add [package name ] 패키지를 프로젝트 의존성 수준으로 추가 (dependencies)   npm install \u0026ndash;save-dev [package name] yarn add \u0026ndash;dev [package name] 패키지를 프로젝트 개발 의존성 수준으로 추가 (Devdependencies)   npm install \u0026ndash;global [package name] yarn global add [package name] 패키지를 전역 수준으로 추가   npm update \u0026ndash;save yarn upgrade 프로젝트의 패키지 업데이트   npm run [script name] yarn [script name] package.json의 scripts에 지정된 명령 실행   npm uninstall \u0026ndash;save [package name] yarn remove [package name] 패키지 삭제   npm cache clean yarn cache clean 캐시 삭제    참고자료  yarn 특징과 성능  "
},
{
	"uri": "http://ccambo.github.io/Cloud/Concepts/edge-computing/",
	"title": "Edge Computing",
	"tags": ["Edge Computing"],
	"description": "Edge Computing에 대한 내용을 정리합니다.",
	"content": " 엣지 컴퓨팅이란? 클라우드 컴퓨팅이란 인터넷을 통해 서버, 저장소, 소프트웨어, 분석 등의 컴퓨팅 서비스를 제공하는 것을 말한다. 이미 많은 기업들이 클라우드 환경으로 전환했으며, 이 과정에서 여러 가지 문제점들이 발생하게 된다.\n 사용자의 폭발적인 증가로 인해 서버 및 데이터 센터에서 처리할 수 있는 데이터 양을 넘어서기 시작하면서 데이터 처리 속도 문제 데이터의 송/수신 과정의 지연 현상 발생 (Latency) 통신 과정 상의 보안 문제  이런 문제점들을 해결하기 위해서 \u0026ldquo;사용자의 단말 또는 가까운 위치에서 컴퓨팅을 수행\u0026rdquo;  하는 방식의 엣지 컴퓨팅 개념이 탄생했다.\n데이터를 데이터 센터로 전송하고 데이터를 처리하는 방식의 클라우드 컴퓨팅과는 달리 엣지 검퓨팅은 스마트폰과 같은 단말(엣지) 기기 또는 가까운 위치에서 데이터를 처리하는 분산 개방형 아키텍처를 말하며 이를 기반으로 모바일 컴퓨팅 및 IoT (Internet of Things) 기술을 활용할 수 있다.\n[출처 : 삼성 뉴스룸 - 엣지컴퓨팅]  [출처 : 위키백과]  엣지 컴퓨팅이 필요한 이유 클라우드 컴퓨팅에서는 발생한 데이터를 클라우드로 전송하고 데이터를 가공하고 결과를 받는 형식이지만 엣지 컴퓨팅에서는 사용자 또는 데이터 소스의 물리적인 위치나 그 위치와 가까운 곳에서 컴퓨팅이 수행되기 때문에 사용자는 더욱 빠르고 안정적인 서비스를 제공받을 수 있으며, 기업은 유연한 하이브리드 클라우드 컴퓨팅의 이점을 얻을 수 있다. 따라서 엣지 컴퓨팅을 활용하면 기업이 다수의 위치에서 공통의 리소스 풀을 사용해서 데이터 연산 및 처리를 분산시킬 수 있는 방법으로 구축이 가능하게 된다.\n 데이터 부하 감소 클라우드 컴퓨팅에서는 모든 발생 데이터가 취합되고 처리되기 때문에 데이터 양에 따른 부하가 생기지만, 엣지 컴퓨팅은 해당 단말 또는 해당 지역에서 발생하는 데이터로 한정되어 처리하므로 부하를 줄일 수 있다. 보안 클라우드 컴퓨팅은 클라우드로 데이터를 전송/전달 단계부터 보안에 대한 요구가 존재하게 되지만, 엣지 컴퓨팅은 데이터 수집과 처리를 해당 단말 또는 가까운 지역에서 처리하므로 상대적으로 보안이 좋다 장애 대응 클라우드 컴퓨팅은 클라우드 장애가 발생하면 치명적이지만, 엣지 컴퓨팅은 자체적으로 컴퓨팅을 수행하기 때문에 효과적으로 대응이 가능하다.  엣지 컴퓨팅 사례  가상/증강 현실 : 종종 대역폭 부족과 긴 지연 시간의 문제가 발생한다. 이로 인해서 몰입이 방해되는 경우가 많기 때문에 엣지 컴퓨팅을 활용해서 렌더링 파이프라인의 컴퓨터 집약적인 부분을 클라우드로 이전하여 이런 문제를 해결할 수 있다. 스마트 카/스마트팩토리 : 길 안내를 하고 있는 상황에서의 데이터 처리 지연은 악몽이 된다. 따라서 자동차 또는 IoT 기기가 엣지 컴퓨팅을 활용해서 실시간 데이터를 처리하고 결정을 내릴 수 있도록 할 수 있다. 보안 및 GDPR(규제 정책) : 엣지 컴퓨팅을 활용해서 컴퓨팅 기능 (데이터 수집과 처리 등)을 로컬 네트워크에서 수행함으로써 민감한 데이터의 유출이 완화되므로 기업들이 정보(영업 비밀 등)의 확산을 효과적으로 통제하고 규제 정책(GDPR 등)을 준수 할 수 있다. 장애 대응 : 엣지 컴퓨팅을 활용해서 클라우드 컴퓨팅 대비 복구 능력과 비용 절감 효과를 누릴 수 있으며, 주요 기능이 로컬 네트워크에서 수행되기 때문에 클라우드가 어떤 이유로 장애가 발생해도 지역 사이트는 독립적으로 계속 운영이 가능하고, 클라우드와 지역 사이트 간의 데이터를 교류하기 위해 소비되는 대역폭 비용도 크게 절감이 가능하다.  엣지 컴퓨팅의 이점  클라우드 컴퓨팅은 몇몇의 대규모 데이터 센터로 서비스를 중앙 집중화하는데 초점에 맞춰져있고 이를 통해서 제어 능력과 기업 보안을 유지하면서도 리소스의 확장성을 높이고 보다 효율적인 공유가 가능하다. 반면에 엣지 컴퓨팅은 주로 네트워크 요구사항 또는 기타 제약으로 클라우드 컴퓨팅의 중앙집중식 접근방식으로 적절하게 해결할 수 없는 활용 사례를 처리한다. 여러 소규모의 컴퓨팅 사이트에 중점을 두고 네트워크 비용을 절감하고 대역폭 제한을 피하며, 전송 지연과 서비스 장애를 줄이고, 민감한 데이터의 이동을 더욱 효과적으로 제어할 수 있다. 어플리케이션의 로드 시간을 단축하고 사용자 가까이에서 배포되는 온라인 서비스를 통해서 동적 및 정적 캐시 기능을 모두 지원할 수 있으므로 최종 사용자에게 더욱 빠르고 일관성있는 사용자 환경을 제공할 수 있다. 기업과 서비스 제공업체는 실시간 모니터링이 가능하며, 지연 시간이 짧고 가용성이 높은 어플리케이션 구현이 가능하다.  엣지 컴퓨팅의 과제 가장 큰 문제점은 고도로 분산된 환경에서 규모를 확장하는 상황에서 발생한다.\n 클라우드 컴퓨팅의 중앙집중적 시스템에서는 스케일 아웃하는 것이 상대적으로 쉽지만, 많은 소규모 사이트가 연계되는 엣지 컴퓨팅에서는 훨씬 복잡하며, 물리적인 위치에 따른 오버헤드가 증가하여 소규모 기업에서 관리하기에는 부담이 될 수 있다. 소규모 사이트는 전문 기술자가 없거나 제한적인 원격지일 가능성이 높기 때문에 장애가 발생하는 경우 비기술 현장 인력이 해결하고 다른 지역의 전문 인력이 중앙에서 관리할 수 있도록 인프라를 구축해야 한다. 각 사이트 관리 작업은 모든 사이트에서 적용 가능하도록 간단해야 하며, 문제 해결을 지원해야 하고, 각 사이트에서 소프트웨어 설정이 다른 방식으로 구현되는 것을 방지할 수 있어야 한다. 데이터를 지리적으로 제한하여 정보의 흐름을 효과적으로 운영할 수는 있지만, 각 사이트에 대한 물리적인 보안은 취약할 수 밖에는 없기 때문에 악의적인 공격이나 우발적인 손상으로 인한 문제 발생 위험은 오히려 더 높을 수 있다.  참고자료  엣지 컴퓨팅? 엣지 컴퓨팅  "
},
{
	"uri": "http://ccambo.github.io/Dev/Vue/vue/",
	"title": "Vue 기본 개념",
	"tags": ["Vue", "Vue.js"],
	"description": "Vue.js에 대한 간략한 기본 개념 소개",
	"content": " 이 문서는 vue에 대한 빠르고 개략적인 이해를 위해서 간략한 개념만을 정리하고 있다. 따라서 실제 프로젝트에 적용하기 위해서는 참고문서에 지정된 공식문서와 다른 분들이 정리해 놓은 자료들을 참고하도록 한다. 현재 진행 중인 프로젝트에 무사히(?) 적용을 끝내고 나면 그 과정을 기준으로 새로운 정리 문서들을 추가할 예정이다.\n Vue? Vue 가 무엇인가에 대한 것은 Vue 키 포인트 소개 (Gregg 소개 자료)를 참고하면 쉽게 이해할 수 있다.\n 현재 Top 3(Angular, React, Vue)에 해당하는 Javascript Framework으로 MVVM(Model-View-ViewModel) 패턴 기반의 UI 라이브러리\n 데이터 바인딩과 화면 단위를 컴포넌트 형태로 제공하며, 관련된 API를 지원한다. 양방향 데이터 바인딩 지원 (Component \u0026lt;-\u0026gt; Model) 컴포넌트간의 통신은 React와 같이 단방향 데이터 흐름 (Parent -\u0026gt; Child) 사용 Angular, React 등과 비교해서 상대적으로 가볍고 빠름 문법이 단순하고 간결해서 진입장벽이 낮고 쉽게 접근 가능 Virtual DOM 지원 Single file copmpoent 지원 View에 최적화되어 있어 jQuery등을 이용한 DOM 조작이 필요없다. 많은 모듈들의 지원과 한글화된 정보들이 많이 존재한다.  Vuex : 중앙집중식 상태관리 저장소 vue-router : SPA를 위한 라우터 vue-resource : HTTP, Ajax, \u0026hellip; vue-devtools : Vue에 최적화된 개발자 모드   MVVM 패턴이란? 서버와 클라이언트의 UI 코드와 데이터를 분리하기 위한 기본적인 구조인 MVC (Model-View-Controller) 패턴에서 파생된 것으로 쉽게 생각하면 서버와 연계되는 데이터(Model)와 UI 코드 및 UI 동작 (View) 간의 분리와 데이터 연계를 위한 중간 매개체로의 역할 (ViewModel)을 담당하는 패턴을 의미한다.\n[ MVVM 패턴 ]  Vue Instance 모든 Vue 어플리케이션들은 Vue 함수를 이용해서 인스턴스를 만드는 것부터 시작된다.\n아래의 예제는 아주 간단한 \u0026ldquo;Hello Vue\u0026rdquo;를 출력하는 기본 샘플이다.\n1\u0026lt;!DOCTYPE html\u0026gt; 2\u0026lt;html\u0026gt; 3 \u0026lt;head\u0026gt; 4 \u0026lt;title\u0026gt;Vue First Sample\u0026lt;/title\u0026gt; 5 \u0026lt;/head\u0026gt; 6 \u0026lt;body\u0026gt; 7 \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; 8 {{ message }} 9 \u0026lt;/div\u0026gt; 10 11 \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/vue/dist/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 12 \u0026lt;script\u0026gt; 13 new Vue({ 14 el: \u0026#39;#app\u0026#39;, 15 data: { 16 message: \u0026#39;Hello Vue.js!\u0026#39; 17 } 18 }) 19 \u0026lt;/script\u0026gt; 20 \u0026lt;/body\u0026gt; 21\u0026lt;/html\u0026gt;  11번 라인에서 Vue.js 스크립트 지정 13-18번 라인에서 Vue Instance 생성 14번 el은 Vue 인스턴스가 마운트될 DOM 의 엘리먼트를 지정 15번 data는 Model 데이터 지정  \u0026lt;script\u0026gt; ... new Vue({ // option properties }) ... \u0026lt;/script\u0026gt; 옵션으로 지정할 수 있는 속성들은 다음과 같다.\n data : 뷰의 반응성(Reactivity)이 반영될 데이터 속성 template : 화면에 표시할 요소 (HTML, CSS 등) el : vue 인스턴스가 연계될 HTML 엘리먼트 methods : 화면의 동작과 이벤트를 처리하기 위한 메서드 events (life cycle hooks) : Vue 라이프사이클에 맞는 이벤트 훅 watch: data에 정의한 속성이 변경 (양방향 Binding)되었을 떄 추가 동작을 수행할 수 있도록 정의하는 속성 \u0026hellip;  옵션으로 지정 가능한 전체 목록은 Vue 공식사이트의 API문서를 참고하면 된다.\n Vue 라이프 사이클 Vue는 아래와 같은 라이프 사이클을 가진다.\n[출처:Vue공식문서 - 라이프사이클 다이어그램]  위의 그림을 단순한 진행 스텝 단위로 정리하면 아래와 같고, 우리가 사용하게될 부분은 굵은 글씨로 표현된 이벤트 훅을 받아서 필요한 처리를 수행하면 된다.\n Vue 인스턴스 생성 events and lifecycle 초기화  beforeCreate 이벤트 훅 발생  injections and reactivity 초기화  created 이벤트 훅 발생  Vue 인스턴스 연결 (el option 지정에 따라 vm.$mount(el) 호출) 템플릿 구성 (템플릿 미지정시는 el의 outerHTML을 템플릿으로 처리)  beforeMount 이벤트 훅 발생  vm.$el 변수 생성 및 el 엘리먼트를 Vue 인스턴스로 대체  mounted 이벤트 훅 발생  데이터 변경 발생시 Virtual DOM에 적용  데이터 변경 전에 beforeUpdate 이벤트 훅 발생 데이터 변경 후에 updated 이벤트 훅 발생  vm.$destroy() 메서드 호출되면 종료 진행  beforeDestroy 이벤트 훅 발생 watchers, child components, event listeners 들 종료 destroyed 이벤트 훅 발생   Vue Components 기본 HTML 엘리먼트를 확장해서 재 사용 가능한 코드로 캡슐화한 것으로 HTML + CSS + SCRIPT 의 구성으로 특정한 기능성을 제공하기 위한 것이다.\n[출처:Cracking Vue.js - 컴포넌트 구성]  따라서 컴포넌트를 기반으로 화면을 개발하면 코드의 재 사용성이 올라가고 일관성 유지를 하면서 빠르게 개발이 가능하다.\nVue는 사용자 지정 태그 이름에 대한 W3C 규칙을 따르지 않고 아래의 규칙을 사용한다. - 모두 소문자로 구성한다.  - \u0026rsquo;-\u0026rsquo; 을 포함해야 한다.\n 전역 컴포넌트 Vue 인스턴스에 직접 컴포넌트를 등록한다. Vue.component(tagName, options)\n1... 2\u0026lt;div id=\u0026#34;example\u0026#34;\u0026gt; 3 \u0026lt;my-component\u0026gt;\u0026lt;/my-component\u0026gt; 4\u0026lt;/div\u0026gt; 5... 6\u0026lt;script\u0026gt; 7... 8// 전역 컴포넌트 등록 9Vue.component(\u0026#39;my-compoent\u0026#39;, { 10 // options 11 template: \u0026#39;\u0026lt;div\u0026gt;사용자 정의 컴포넌트!!\u0026lt;/div\u0026gt;\u0026#39; 12}) 13... 14// 인스턴스 생성 15new Vue({ 16 // option properties 17 el: \u0026#39;#example\u0026#39; 18}) 19 20... 21\u0026lt;/script\u0026gt; 실행된 결과는 다음과 같다.\n1// 렌더링 결과 2\u0026lt;div id=\u0026#34;example\u0026#34;\u0026gt; 3 \u0026lt;div\u0026gt;사용자 정의 컴포넌트!!\u0026lt;/div\u0026gt; 4\u0026lt;/div\u0026gt; 지역 컴포넌트 모든 컴포넌트를 전역으로 등록할 필요는 없다. 컴포넌트를 components 라는 인스턴스 옵션으로 등록해서 다른 인스턴스 또는 컴포넌트의 범위 내에서 사용하도록 할 수도 있다.\n1var Child = { 2 template: \u0026#39;\u0026lt;div\u0026gt;사용자 정의 컴포넌트!!\u0026lt;/div\u0026gt;\u0026#39; 3} 4 5new Vue({ 6 // ... 7 components: { 8 // \u0026lt;my-component\u0026gt; 는 상위 템플릿에서만 사용할 수 있습니다. 9 \u0026#39;my-component\u0026#39;: Child 10 } 11}) 컴포넌트 사용시 주의할 점  DOM 템플릿 구문 오류 Vue는 템플릿 컨텐츠를 처리할 때 HTML이 동작하는 고유의 몇가지 제한 사항이 존재하며 브라우저가 구문 분석과 정규화한 후에 동작하기 때문에 \u0026lt;ul\u0026gt;, \u0026lt;ol\u0026gt;, \u0026lt;table\u0026gt;, \u0026lt;select\u0026gt;와 \u0026lt;option\u0026gt; 등과 같이 제한이 존재하는 경우는 오류가 발생하게 된다. 따라서 이런 문제를 해결하기 위해서는 is 라는 특수한 속성을 이용해야 한다. 1 \u0026lt;table\u0026gt; 2 \u0026lt;my-row\u0026gt;...\u0026lt;/my-row\u0026gt; \u0026lt;!-- \u0026lt;tr\u0026gt; 태그가 아닌 사용자 정의 컴포넌트가 존재하므로 오류 발생 --\u0026gt; 3 \u0026lt;/table\u0026gt; 4 5 \u0026lt;!-- 위의 문제를 해결하기 위해서는 아래와 같이 특수 속성을 사용해야 한다. --\u0026gt; 6 \u0026lt;table\u0026gt; 7 \u0026lt;tr is=\u0026#34;my-row\u0026#34;\u0026gt;...\u0026lt;/my-row\u0026gt; \u0026lt;!-- \u0026lt;tr\u0026gt; 에 \u0026#34;is\u0026#34; 속성으로 컴포넌트 연결 --\u0026gt; 8 \u0026lt;/table\u0026gt; 9  물론 순수하게 DOM 파싱을 거치지 않는 경우는 예외적으로 사용할 수 있다.  \u0026lt;script type=\u0026quot;text/x-template\u0026quot;\u0026gt; 에서 사용하는 경우 Javascript 인라인 템플릿 문자열 .vue 컴포넌트  data option은 반드시 함수여야 한다 Vue 생성자에 사용할 수 있는 대부분의 옵션들은 컴포넌트에서도 사용할 수 있지만 data의 경우는 반드시 함수여야 한다. 1 Vue.component(\u0026#39;my-component\u0026#39;, { 2 template: \u0026#39;\u0026lt;span\u0026gt;{{ message }}\u0026lt;/span\u0026gt;\u0026#39;, 3 data: { // 함수가 아니므로 경고 표시됨. 4 message: \u0026#39;hello\u0026#39; 5 } 6 }) 7  아래와 같이 함수로 처리해서 사용하면 된다. 1 ... 2 \u0026lt;div id=\u0026#34;example-2\u0026#34;\u0026gt; 3 \u0026lt;simple-counter\u0026gt;\u0026lt;/simple-counter\u0026gt; 4 \u0026lt;simple-counter\u0026gt;\u0026lt;/simple-counter\u0026gt; 5 \u0026lt;simple-counter\u0026gt;\u0026lt;/simple-counter\u0026gt; 6 \u0026lt;/div\u0026gt; 7 ... 8 \u0026lt;script\u0026gt; 9 var data = { counter: 0 } 10 11 Vue.component(\u0026#39;simple-counter\u0026#39;, { 12 template: \u0026#39;\u0026lt;button v-on:click=\u0026#34;counter += 1\u0026#34;\u0026gt;{{ counter }}\u0026lt;/button\u0026gt;\u0026#39;, 13 // 데이터는 기술적으로 함수이므로 Vue는 따지지 않지만 14 // 각 컴포넌트 인스턴스에 대해 같은 객체 참조를 반환합니다. 15 data: function () { 16 return data // 객체 반환 17 } 18 }) 19 20 new Vue({ 21 el: \u0026#39;#example-2\u0026#39; 22 }) 23 \u0026lt;/script\u0026gt; 24  위의 예제는 정상적으로 잘 동작을 하지만 잘 보면 data란 객체를 생성하고 이를 반환하는 함수로 data 옵션을 구성했기 때문에 모든 컴포넌트가 동일한 객체를 바라보기 때문에 하나의 컴포넌트에서 값을 바꾸면 모든 컴포넌트가 변경되는 문제가 발생한다. 이를 해결하기 위해서는 아래와 같이 코드를 작성해야 한다. 1 ... 2 \u0026lt;div id=\u0026#34;example-2\u0026#34;\u0026gt; 3 \u0026lt;simple-counter\u0026gt;\u0026lt;/simple-counter\u0026gt; 4 \u0026lt;simple-counter\u0026gt;\u0026lt;/simple-counter\u0026gt; 5 \u0026lt;simple-counter\u0026gt;\u0026lt;/simple-counter\u0026gt; 6 \u0026lt;/div\u0026gt; 7 ... 8 \u0026lt;script\u0026gt; 9 Vue.component(\u0026#39;simple-counter\u0026#39;, { 10 template: \u0026#39;\u0026lt;button v-on:click=\u0026#34;counter += 1\u0026#34;\u0026gt;{{ counter }}\u0026lt;/button\u0026gt;\u0026#39;, 11 // 데이터는 기술적으로 함수이므로 Vue는 따지지 않지만 12 // 각 컴포넌트 인스턴스에 대해 같은 객체 참조를 반환합니다. 13 data: function () { 14 return 0 // 객체마다 0 반환 (고유 값 배정됨) 15 } 16 }) 17 18 new Vue({ 19 el: \u0026#39;#example-2\u0026#39; 20 }) 21 \u0026lt;/script\u0026gt; 22   컴포넌트간의 관계 컴포넌트는 주로 부모-자식 관계로 구성된다. 부모 컴포넌트의 템플릿에서 자식 컴포넌트를 지정해서 사용하는 방식이기 때문에 서로 간의 정보 소통이 필요하다.\n[출처:Vue공식문서 - 컴포넌트 관계]  위의 그림과 같이 부모는 자식에서 속성 값을 전달하고, 자식은 부모에서 이벤트로 전달하는 방식을 취하기 때문에 각 컴포넌트의 코드가 격리된 상태로 운영되고 재 사용할 수 있다.\n 부모에서 자식으로 데이터 전달\n props 데이터 전달  prop는 부모 컴포넌트의 정보를 전달하기 위한 사용지 지정 특성이며, 자식 컴포넌트는 props 옵션을 사용해서 받을 수 있다. 1 \u0026lt;script\u0026gt; 2 Vue.component(\u0026#39;child\u0026#39;, { 3 // props 정의 4 props: [\u0026#39;message\u0026#39;], 5 // 데이터와 마찬가지로 prop은 템플릿 내부에서 사용할 수 있으며 6 // vm의 this.message로 사용할 수 있습니다. 7 template: \u0026#39;\u0026lt;span\u0026gt;{{ message }}\u0026lt;/span\u0026gt;\u0026#39; 8 }) 9 \u0026lt;/script\u0026gt; 10 11 \u0026lt;child message=\u0026#34;안녕하세요!\u0026#34;\u0026gt;\u0026lt;/child\u0026gt; \u0026lt;!-- 부모 컴포넌트에서 message라는 props로 지정된 속성을 통해서 값 전달 --\u0026gt; 12  props 설정할 때의 camelCase, kebab-case 사용 스크립트에서는 카멜케이스를 사용하지만 HTML에서는 대소문자를 구별하지 않기 때문에 템플릿에서 사용할 때는 케밥케이스를 사용해야 한다. 1 \u0026lt;child my-message=\u0026#34;안녕하세요!\u0026#34;\u0026gt;\u0026lt;/child\u0026gt; \u0026lt;!-- HTML는 kebab-case를 사용해서 `my-message`로 표현 --\u0026gt; 2 3 \u0026lt;script\u0026gt; 4 Vue.component(\u0026#39;child\u0026#39;, { 5 props: [\u0026#39;myMessage\u0026#39;], // JavaScript는 camelCase로 `myMessage`로 표현 6 template: \u0026#39;\u0026lt;span\u0026gt;{{ myMessage }}\u0026lt;/span\u0026gt;\u0026#39; 7 }) 8 \u0026lt;/script\u0026gt; 9  문자열 템플릿을 이용하는 경우는 이 제한이 적용되지 않는다.   자식 컴포넌트에서 부모 컴포넌트로 데이터 전달\n 템플릿에 v-on:eventName을 지정해서 부모 자식간의 이벤트 전달 및 수신 자식 컴포넌트에서 $emit(eventName)을 호출해서 부모로 전달할 이벤트 작동 1 \u0026lt;div id=\u0026#34;counter-event-example\u0026#34;\u0026gt; 2 \u0026lt;p\u0026gt;{{ total }}\u0026lt;/p\u0026gt; \u0026lt;!-- 자식 컴포넌트에서 잔달된 값을 누적해서 출력 --\u0026gt; 3 \u0026lt;button-counter v-on:increment=\u0026#34;incrementTotal\u0026#34;\u0026gt;\u0026lt;/button-counter\u0026gt; \u0026lt;!-- v-on:increment 설정으로 자식에서 전달된 이벤트 수신하여 incrementTotal 메서드 호출 (부모 컴포넌트 입장의 이벤트 수신) --\u0026gt; 4 \u0026lt;button-counter v-on:increment=\u0026#34;incrementTotal\u0026#34;\u0026gt;\u0026lt;/button-counter\u0026gt; \u0026lt;!-- v-on:increment 설정으로 자식에서 전달된 이벤트 수신하여 incrementTotal 메서드 호출 (부모 컴포넌트 입장의 이벤트 수신) --\u0026gt; 5 \u0026lt;/div\u0026gt; 6 7 \u0026lt;script\u0026gt; 8 Vue.component(\u0026#39;button-counter\u0026#39;, { 9 template: \u0026#39;\u0026lt;button v-on:click=\u0026#34;incrementCounter\u0026#34;\u0026gt;{{ counter }}\u0026lt;/button\u0026gt;\u0026#39;, // 자식 컴포넌트의 click 이벤트 처리 10 data: function () { 11 return { 12 counter: 0 13 } 14 }, 15 methods: { 16 incrementCounter: function () { 17 this.counter += 1 18 this.$emit(\u0026#39;increment\u0026#39;) // 부모로 전달될 수 있도록 \u0026#39;increment\u0026#39; 이벤트 호출 19 } 20 }, 21 }) 22 23 new Vue({ 24 el: \u0026#39;#counter-event-example\u0026#39;, 25 data: { 26 total: 0 27 }, 28 methods: { 29 incrementTotal: function () { 30 this.total += 1 31 } 32 } 33 }) 34 \u0026lt;/script\u0026gt; 35    동일 레벨 컴포넌트간의 통신 동일 컴포넌트간의 직접적인 통신 방법은 제공되지 않는다.\n 동일한 Parent를 가지는 Child 간의 통신은 Child \u0026gt; Parent \u0026gt; Child 방식으로 통신을 해야 한다. 상/하위 관계가 아닌 경우는 Event Bus 를 활용해야 한다. 이 때는 화면과 연동되는 Vue 인스턴스가 아닌 빈 인스턴스를 하나 더 만들어서 Event Bus 용도로 사용하면 된다. 1 \u0026lt;script\u0026gt; 2 var eventBus = new Vue(); // Event Bus로 활용하기 위한 별도의 Vue 인스턴스 생성 3 4 // 화면 처리용 Vue 인스턴스 5 new Vue({ 6 // ... 7 }) 8 ... 9 // 데이터를 보낼 컴포넌트에서 `$emit` 사용 10 eventBus.$emit(\u0026#39;refresh\u0026#39;, 10); 11 ... 12 // 데이터를 받는 컴포넌트에서 `$on` 사용, 단 Event Bus의 이벤트 수신은 라이프사이클 함수에서 처리 13 new Vue({ 14 created: function() { 15 // Vue created event hook에서 Event Bus 수신 처리 정의 16 eventBus.$on(\u0026#39;refresh\u0026#39;, function(data) { 17 console.log(data); // 10 18 }); 19 } 20 }) 21 \u0026lt;/script\u0026gt; 22  만일 Event Bus의 콜백 함수 내에서 해당 메서드를 참고할 경우는 vm사용 1 \u0026lt;script\u0026gt; 2 new Vue({ 3 methods: { 4 callAnyMethod() { // Event Bus에서 호출할 Vue 인스턴스내의 메서드 5 // ... 6 } 7 }, 8 created() { 9 var vm = this; // Vue 인스턴스를 vm에 설정 10 eventBus.$on(\u0026#39;refresh\u0026#39;, function(data) { 11 console.log(this); // 여기서의 this는 이벤트 버스용 인스턴스를 가리킴 12 vm.callAnyMethod() // vm은 현재 인스턴스를 가리킴 13 }); 14 } 15 }) 16 \u0026lt;/script\u0026gt; 17   자바스크립트에서의 this는 상황에 따라서 다른 문맥객체로 동작한다. 위의 예제에서도 굳이 this를 vm이라는 변수로 설정해 놓는 이유도 외부 메서드와 내부 메서드의 문맥객체가 다르기 때문이다. 일반적으로 this는 아래와 같은 상황들에서 다른 문맥객체로 처리된다. - 함수 실행 : this는 전역 객체 문맥을 가진다. (브라우저라면 아마도 window 객체일 것이다) - 엄격모드에서의 함수 실행 : this는 undefined가 된다. - 메서드 실행 : this는 메서드를 소유하고 있는 객체로서의 문맥을 가진다. - 생성자 실행 : this는 새롭게 인스턴싱된 객체로서의 문맥을 가진다. - \u0026hellip; 실행되는 상태에 따라서 this는 의미가 다른 문맥을 가르키게 되므로 항상 이 부분을 조심해야 한다.\n Vue Routers Vue Router는 Vue 코어 라이브러리와 함께 공식 라이브러리로 제공되고 있다. 주로 Vue를 이용해서 SPA (Single Page Application) 어플리케이션을 작성할 때 사용된다.\n설치는 CDN과 NPM 모두 지원한다.\n CDN 설치 \u0026lt;script src=\u0026#34;https://unpkg.com/vue-router/dist/vue-router.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;  NPM 설치 npm install vue-router --save   Vue 라우터는 기본적으로 'Root URL'/#/'Router name' 구조를 가진다.\nexample.com/#/user 위의 구조에서 기본 사용되고 있는 \u0026ldquo;#\u0026ldquo;을 제거하고 싶은 경우는 아래와 같이 속성을 지정하면 된다.\nnew VueRouter({ mode: \u0026#39;history\u0026#39; })   Nested Router 라우터를 기준으로 화면을 이동할 때 Nested Router를 이용해서 지정된 하위 컴포넌트를 표시할 수 있다. 물론 컴포넌트의 구조는 Parent - Child 구조여야 한다. 1 ... 2 \u0026lt;!-- localhost:5000 --\u0026gt; 3 \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; 4 \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; 5 \u0026lt;/div\u0026gt; 6 7 \u0026lt;!-- localhost:5000/home --\u0026gt; 8 \u0026lt;div\u0026gt; 9 \u0026lt;p\u0026gt;Main Component rendered\u0026lt;/p\u0026gt; 10 \u0026lt;app-header\u0026gt;\u0026lt;/app-header\u0026gt; 11 \u0026lt;/div\u0026gt; 12 ... 13 \u0026lt;script\u0026gt; 14 ... 15 // \u0026#39;localhost:5000/home\u0026#39;에 접근하면 Main과 Header 컴포넌트 둘다 표시된다. 16 { 17 path : \u0026#39;/home\u0026#39;, 18 component: Main, 19 children: [ 20 { 21 path: \u0026#39;/\u0026#39;, 22 component: AppHeader 23 }, 24 { 25 path: \u0026#39;/list\u0026#39;, 26 component: List 27 }, 28 ] 29 } 30 ... 31 \u0026lt;/script\u0026gt; 32 \n Named Views 특정 URL로 이동했을 때 여러 개의 컴포넌트를 동시에 표현할 수 있는 방법이다. 1 ... 2 \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; 3 \u0026lt;router-view name=\u0026#34;appHeader\u0026#34;\u0026gt;\u0026lt;/router-view\u0026gt; 4 \u0026lt;router-view\u0026gt;\u0026lt;/router-view\u0026gt; 5 \u0026lt;router-view name=\u0026#34;appFooter\u0026#34;\u0026gt;\u0026lt;/router-view\u0026gt; 6 \u0026lt;/div\u0026gt; 7 ... 8 { 9 path : \u0026#39;/home\u0026#39;, 10 // Named Router 11 components { 12 appHeader: AppHeader, 13 default: Body, 14 appFooter: AppFooter 15 } 16 } 17 ... 18 \u0026lt;/script\u0026gt; 19 \n Nested Router vs. Named Views\n 특정 URL에 지정된 1개 이상의 컴포넌트가 여러 개의 하위 컴포넌트를 갖는 것을 Nested Router라고 한다. 특정 URL에 여러 개의 컴포넌트를 영역 별로 지정해서 렌더링하는 것을 Named View라고 한다.   [ Nested Routers vs. Named Views ]  HTTP 통신 Vue에서 HTTP 통신을 위해서 가장 많이 사용하는 라이브러리는 Axios로 CDN과 NPM 설치 방식을 모두 지원하며 사용하기 편리한 API와 속성들이 많다. 기본적으로 Promise 기반이기 때문에 코드를 간결하게 작성할 수 있다.\n CDN 설치 \u0026lt;script src=\u0026#34;https://unpkg.com/axios/dist/axios.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;  NPM 설치 npm install axios   실제 사용 방법은 다음과 같다.\n... methods: { fetchData: function() { axios.get(\u0026#39;URL 주소\u0026#39;) .then(res =\u0026gt; { console.log(res.data) }) } } ...  좀 더 자세한 설명과 샘플은 아래의 참고자료 참고\nVue Template 템플릿은 Vue에서 화면을 표현하기 위해서 제공되는 문법으로 Vue 인스턴스에서 관리하는 데이터와 화면과의 연계를 위한 데이터 바인딩(Data Binding)과 화면의 조작을 위한 지시자(Directive)로 나뉜다.\n Data Binding \u0026quot;{{ ... }}\u0026quot;를 활용해서 인스턴스의 data, computed, props 속성들을 연결할 수 있다. 또한 간단한 자바스크립트 표현식도 사용할 수 있다. \u0026lt;div\u0026gt;{{ str }}\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;{{ number + 1 }}\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;{{ message.split(\u0026#39;\u0026#39;).reverse().join(\u0026#39;\u0026#39;) }}\u0026lt;/div\u0026gt;  Directive HTML 태그의 속성에 v- 접두사가 붙은 특별한 속성으로 화면의 DOM 조작을 쉽게할 수 있는 문법들을 제공한다. \u0026lt;!-- 조건문 처리 : seen의 true/false에 따라 p 태그의 표시여부 결정 --\u0026gt; \u0026lt;p v-if=\u0026#34;seen\u0026#34;\u0026gt;Now you see me\u0026lt;/p\u0026gt; \u0026lt;!-- 화면에 a 태그가 표시되는 시점에 Vue 인스턴스에서 관리하는 url 데이터 값을 href 속성 값으로 바인딩 처리 --\u0026gt; \u0026lt;a v-bind:href=\u0026#34;url\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;!-- button의 클릭 이벤트로 doSomething이라는 메서드를 실행 --\u0026gt; \u0026lt;button v-on:click=\u0026#34;doSomething\u0026#34;\u0026gt;\u0026lt;/button\u0026gt;  Filters 화면에 표시되는 텍스트의 형식을 편하게 설정할 수 있도록 하는 기능으로 파이프 문자(|)를 이용해서 여러 개의 필터를 적용할 수 있다. 1 \u0026lt;!-- message 값에 capitalize 필터를 적용하여 첫 글자를 대문자로 변경 --\u0026gt; 2 {{ message | capitalize }} 3 ... 4 \u0026lt;script\u0026gt; 5 new Vue({ 6 filters: { 7 capitalize: function(value) { 8 if (!value) return \u0026#39;\u0026#39;; 9 value = value.toString(); 10 return value.charAt(0).toUpperCase() + value.slice(1); 11 } 12 } 13 }) 14 \u0026lt;/script\u0026gt; 15  위의 샘플은 \u0026ldquo;message\u0026rdquo; 데이터를 출력하는데 \u0026ldquo;capitalize\u0026rdquo;라는 Vue 인스턴스에 정의된 Filters 메서드를 호출해서 첫 글자를 대문자로 변경한 후에 이 결과를 출력하도록 처리하는 방식이다.  Single File Component UI에 대해서 특정 기능을 제공하는 컴포넌트로 하나의 파일 내에서 HTML, CSS, JS 코드를 모두 지원한다. 확장자는 .vue를 사용하고 HTML 파일 내에서 Vue 개발을 진행했을 때의 한계를 극복할 수 있는 방법이다.\nHTML 파일 내에서 개발할 때의 한계점들은 다음과 같다.\n 모든 컴포넌트의 유일한 식별을 위해서 공유의 이름을 지정해야 한다. js 파일에서 template 안의 HTML 문법 강조가 되지 않는다. js 파일에서 css 스타일 작업이 거의 불가능하다. ES5를 이용해서 계속 앱을 작성할 경우 Babel 빌드가 지원되지 않는다.  기본적인 골격은 다음과 같다.\n\u0026lt;template\u0026gt; \u0026lt;!-- HTML --\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; // Javascript \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; /* CSS */ \u0026lt;/style\u0026gt; Vue Loader Single File Component로 작성된 컴포넌트를 브라우저에서 실행가능한 자바스크립트 파일로 변환해 주는 Webpack Loader로 Vue Loader를 사용하면 다음과 같은 장점이 있다.\n ES6 지원 \u0026lt;style\u0026gt;, \u0026lt;template\u0026gt;에 대한 각각의 Webpack Loader 지원 (eg. sass, jade, \u0026hellip;) .vue 컴포넌트의 범위(scope)로 대상으로 하는 css 스타일 지원 Webpack 모듈 번들링에 대한 지원과 의존성 관리 제공 개발 시에 HMR (Hot Module Replacement) 지원  Vue CLI Vue CLI3는 Vue.js 개발을 위한 시스템으로 Vue.js Core에서 공식으로 제공하는 CLI (Command Line Interface)로 Vue 어플리케이션 개발에 집중할 수 있도록 프로젝트 생성을 위한 명령어 도구로 Node 기반에서 동작하므로 당연히 Node가 사전 설치가 되어 있어야 한다.\n또한 Vue 생태계에서 표준 툴을 목표로 하고 있다. 프로젝트를 구성하고 스캐폴딩에 도움을 주는 것이기 때문에 반드시 필요한 것은 아니지만 Vue.js와 관련된 오픈소스들은 대부분 Vue CLI를 통해서 설치가 가능하기 때문에 사용하는 것이 좋다.\n주요 사용은 다음과 같다.\n vue 명령어  $ vue create : 프로젝트 생성 $ vue ui : 제공되는 ui를 통해서 프로젝트 관리  CLI Service : webpack, webpack-dev-server 위에 구축되며 CLI Plugin을 실행하는 핵심 서비스와 webpack에 대한 설정을 포함하고 있다. 즉, webpack을 기반으로 어플리케이션의 개발, 빌드, 실행을 처리한다. CLI Plugin : Babel, Typescript, ESLint, e2d Test 등과 같은 선택적으로 설치가 필요한 Plugin을 말하며, 프로젝트 생성 시점에 포함하거나 이후에 포함시킬 수 있다.  자세한 내용은 아래의 참고자료를 참고하면 된다.\nVirtual DOM React처럼 Vue도 Virtual DOM을 사용한다. Virtual DOM은 화면을 위한 기반 기술로 화면의 DOM에 추가/삭제 등의 변경이 발생하면 화면을 다시 그리는 것이 아니라 자바스크립 상에 객체로 DOM의 구조를 설정해 놓고, 실제 변경이 발생한 경우에 그 부분만 화면을 그릴 수 있도록 해서 브라우저가 화면을 다시 그리는 부하를 줄이는 기법이다.\n동작하는 방법은 아래와 같이 추상적으로 예상해 볼 수 있다.\n DOM이 Load되면 DOM의 Tag들을 Javascript JSON 객체로 복제한다. Vue의 변경에 대한 작업은 모두 복제된 JSON 객체를 대상을 이루어진다. JSON 객체에서 Diff 정보를 추출한다. Diff 정보를 기준으로 실제 DOM의 어떤 부분이 변경되었는지를 확인하고 해당 부분만 갱신한다.  자세한 샘플은 아래의 참고자료를 참고하면 된다.\n참고자료  Vue.js 공식문서 Cracking Vue.js Wiki - MVVM Understanding the Virtual DOM Vue.JS - Vue-CLI3 시작하기 Vue.js에서 axios를 사용하여 서버통신하는 방법 Vue Router  "
},
{
	"uri": "http://ccambo.github.io/Git/Tips/how-to-change-users/",
	"title": "How to Change Users",
	"tags": ["Git", "Change Users"],
	"description": "Git 사용 중에 사용자 변경 관련 오류를 해결하는 방법을 정리합니다.",
	"content": " 대부분의 경우는 단일 사용자로 Git를 운영하겠지만 다양한 이유에 의해서 Git 사용자를 변경해야 하는 상황이 존재한다.\n여기서는 이런 문제를 해결하는 방법에 대해서 알아본다.\n발생 상황 git 설치 후에 기본 환경 설정을 했을 것이다.\n git 환경 설정  # 전역 설정인 경우 $ git config --global user.name \u0026#34;user name\u0026#34; $ git config --global user.email \u0026#34;user email\u0026#34; # git 단위 설정인 경우 $ git config user.name \u0026#34;user name\u0026#34; $ git config user.email \u0026#34;user email\u0026#34;   이런 상황에서 지정한 사용자로 Git에 로그인 한 후에 다른 사용자를 사용해서 push를 하면 다음과 같은 오류가 발생하게 된다.\n 다른 사용자로 로그인된 상태에서 git push 오류 발생  $ git push origin master # terminal에서 실행한 것과 VSCode와 같은 IDE에 연동한 경우도 동일한 상황이 발생한다. remote: Permission [git_url.git] denied to [user_id] fatal: unable to acess `[git_url]`: The requested URL returned error: 403 ...   오류 메시지 내용은 해당 사용자로 remote repository에 push할 권한이 없다는 것이다.\n해결 방법 구글을 검색해 보면 대부분 아래와 같은 해법을 제시한다.\n 사용할 git 프로젝트에서 config 설정을 사용자에 맞도록 변경하면 된다.  git 환경 프로젝트 단위 설정  $ git config user.name \u0026#34;new user name\u0026#34; $ git config user.email \u0026#34;new user email\u0026#34;     권장하는 방식으로 해 봐도 동일한 오류가 발생한다. (당연히 이미 로그인 사용자 정보를 기준으로 하므로 설정을 바꾼다고 해서 로그인 정보가 변경되지는 않는다) ssh 키 관련해서 여러 가지 처리를 제시하는 것도 있지만, 제대로 안되는 상황이 발생한다.  환경 설정을 바꿨기 때문에 지금 push 하려는 사용자와 로그인 사용자가 달라졌으므로 로그인을 다시 물어봐야 할 것 같은데, 실제로는 로그인을 다시 물어보지 않는다.\n의외로 쉽게 해결하는 방법은 다음과 같다.\n Mac 환경\n Spotlight 검색 등으로 키 체인 접근 앱을 실행한다. [ Spotlight 검색 ] \n 키 체인 접근 앱에서 로그인을 선택하고 github.com을 찾아서 더블클릭한다. [ Key chain access ] \n 로그인 정보 창에서 계정과 암호를 변경하고 저장한다. [ Github 로그인 변경 ] \n  Windows 환경\n 제어판 \u0026gt; 사용자 계정 \u0026gt; 자격 증명 관리자를 실행한다. windows 자격 증명 항목의 github 관련 정보를 수정한다. 위와 같이 설정한 후에 다시 push를 실행하면 잘 처리가 된다.   결론 오류의 원인이 로그인된 사용자 정보를 그대로 사용하려고 하는 것이기 때문에 터미널을 사용하던 VSCode와 같이 IDE에 연동해서 사용하던 이미 사용했던 로그인 정보를 삭제 또는 변경해서 로그인을 다시하면 쉽게 해결이 가능하다.\n"
},
{
	"uri": "http://ccambo.github.io/Git/Submdule/what-is-the-submodule/",
	"title": "What is the submodule",
	"tags": ["Git", "Submodule"],
	"description": "Git의 Submodule에 관련된 내용을 정리합니다.",
	"content": " 아래의 내용은 정리하면서 검증한 부분도 있지만, 검증이 되지 않고 정리된 내용도 있을 수 있으므로, 반드시 관련된 정보를 추가로 검색하여 검증해야 한다.\n Submodule? Git 프로젝트는 하나의 독립된 라이브러리라고 생각할 수 있다. 따라서 특정 프로젝트를 진행할 때 또 다른 프로젝트를 내부적으로 사용해야하는 경우가 빈번하게 발생할 수 있다. 일반적으로 이런 상황에서는 필요한 라이브러리의 특정 버전을 설치하거나 소스를 복사해서 사용하는 방법을 사용하는데 이에 따른 버전관리나 소스의 변경등에 대한 대처가 만만치 않다.\nGit와 Submodule을 사용하면 Git Repository 내에 또 다른 독립적인 Repository를 운영하는 구조를 만들 수 있다. 당연히 각 Repository는 독립적으로 관리된다.\n이런 상황이 새로운 것일까? Node 환경이라면 이미 npm을 이용해서 package를 관리하며 사용하고 있다. 그런데 가져다 쓸 패키지가 git에 repository로만 존재하는 경우라면 어떻게 해야할 까? 이런 상황에 대체하기 위한 것이 submodule이고 정리하면 \u0026ldquo;submodule은 git repository 하위에 다른 git repository를 관리하기 위한 도구\u0026rdquo;  라고 생각하면 된다. 자세한 내용은 Pro Git의 내용을 참고!\n 사용법 정리 기본 옵션들 git submodule에 대한 공식 옵션은 다음의 명령으로 확인 가능하다.\n git submodule 도움말  $ git submodule --help   main project와 submodule project 관계 main project에 submodule을 추가하면 submodule들을 관리하기 위한 .gitmodules  파일이 생성되고 여기에 submoudle에 대한 폴더와 repository 정보가 관리되며 main project는 추가된 submodule에 대한 commit point를 바라보고 있게 된다.\n따라서 main project와 submodule 간의 처리는 아래와 같은 순서에 주의해야 한다.\n clone / pull / update : 리모트에서 로컬로 데이터를 가져올 경우는 Parent 먼저  처리 후 submodule을 처리해야 한다. commit / push : 로컬 commit과 리모트로 데이터를 전송하는 경우는 submodule 먼저  처리 후 Parent를 처리해야 한다.  main project가 submodule에 대한 commit point를 연계하고 있기 떄문에 위의 순서가 맞지 않으면 잘못된 submodule의 commit point를 바라보게 되므로 문제가 발생할 수 있다.\n submodule 추가  submodule 추가 (Main Project Root 폴더)  $ git submodule add [-b branch_name] \u0026lt;repository address\u0026gt; [path] # path를 생략하면 현재 경로 밑으로 repository 이름으로 생성된다.   정상적으로 추가되면 main project 경로에 .gitmodules 파일이 생성되며, 내용은 아래와 같이 구성된다.\n .gitmodules 파일 내용 (Main Project Root 폴더)  [submodule \u0026#34;themes/hugo-theme-docdock\u0026#34;] path = themes/hugo-theme-docdock url = https://github.com/vjeantet/hugo-theme-docdock.git   위와 같이 Root Repository (여기서는 Hugo로 만든 사이트) 를 기준으로 경로와 git repository url이 관리되고 있는 것을 확인할 수 있다.\nsubmodule이 추가된 것은 main project가 변경된 것을 의미하기 때문에 commit을 수행해 줘야 한다. 특정 branch로 지정할 경우는 -b \u0026lt;branch name\u0026gt;을 사용하면 된다. 또한 나중에 submodule에 대한 branch를 설정할 경우는 아래와 같이 처리할 수도 있다.\n submodule에 대한 Branch 설정 (Main Project Root 폴더)  $ git config -f .gitmodules submodule.\u0026lt;submodule path\u0026gt;.branch \u0026lt;branch name\u0026gt;   submodule 상태 확인 기본적인 git 상태 확인은 아래의 명령을 사용하며 submodule과 연동해서 사용할 수 있다.\n submodule 상태 확인 (Main Project Root 폴더)  # main project 상태 확인 $ git status # submodule 상태 확인 $ git submodule status # main project 상태확인에 submodule 정보 추가해서 보기 설정 $ git config status.submodulesummary 1   main project에서 바라보는 submodule 상태  main project에서 바라보는 submodule 상태 (Main Project Root 폴더)  $ git diff --cached \u0026lt;submodule path\u0026gt; new file mode 160000 index 0000000..51dbdcf --- /dev/null +++ b/themes/hugo-theme-learn @@ -0,0 +1 @@ +Subproject commit 51dbdcf4aaef01d02e78a6ea76b2a6fde5842b55   위의 내용을 검토해 보면 다음과 같은 특징이 존재한다.\n mode 160000은 일반적인 파일이나 디렉토리가 아니라는 의미를 가진다. Subproject commit 51dbdcf4aaef01d02e78a6ea76b2a6fde5842b55는 main project가 submodule repository의 51dbdcf4aaef01d02e78a6ea76b2a6fde5842b55 commit 정보를 바라보고 있다는 의미를 가진다.  Detached HEAD 문제 Detached HEAD 문제란 submodule update 명령이 수행되면 해당 submodule이 어떤 branch에도 속하지 않는 분리된 HEAD 정보를 가지는 상태를 말하는 것으로 branch를 지정해 줘야 한다. 따라서 아래와 같이 각 단계별 명령을 수행할 때 지정해 주는 것이 좋다.\n Detach HEAD 방지 처리 (Main Project Root 폴더)  # 처음 clone할 때 $ git submodule init $ git submodule udpate $ git submodule foreach git checkout \u0026lt;branch name\u0026gt; # pull/update할 때 $ git pull $ git submodule update --remote --merge # push할 때 $ git push --recurse-submodules=check   git detached HEAD에 대한 내용은 정보를 참고하고, submodule과 detached HEAD에 대한 내용은 정보를 참고하면 된다.\n 단축 명령 및 Config 설정 위에서 알아본 명령들을 별칭(Alias) 등록을 통해서 단축 명령으로 수행할 수도 있다.\n Alias 기준 단축 명령 등록 (Main Project Root 폴더)  # git sdiff 단축 정의 $ git config alias.sdiff \u0026#39;!\u0026#39;\u0026#34;git diff \u0026amp;\u0026amp; submodule foreach \u0026#39;git diff\u0026#39;\u0026#34; # git spush 단축 정의 $ git config alias.spush \u0026#39;push --recurse-submodules=check\u0026#39; # git supdate 단축 정의 $ git config alias.supdate \u0026#39;submodule update --remote --merge\u0026#39;   main project에 아래와 같이 정보를 설정해 두면 활용하기 쉽다.\n main project에 submodule연계 환경 설정 (Main Project Root 폴더)  # login $ git config credential.helper cache # status $ git config status.submodulesummary 1 # diff $ git config diff.submodule log   이미 submodule을 포함하고 있는 Repository 활용하기 clone and update submodules  Parent git project clone : .gitmodules 파일이 존재하며, 파일내에 어떤 폴더에 어떤 git repository를 사용하는지에 대한 정보를 알 수 있다.  Parent 프로젝트 Clone  $ git clone \u0026lt;main project repository\u0026gt;   \n submodule clone  submodule 프로젝트들 Clone (Clone된 Main Project Root 폴더)  $ git submodule init # submodule 초기화 $ git submodule update # submodule 갱신(다운로드 - Detached HEAD 상태로 어떤 branch에도 속하지 않는 상태) $ git submodule foreach git checkout \u0026lt;branch name\u0026gt; # 지정한 branch로 설정   \n  위의 clone 과정을 한번에 처리할 수도 있다. $ git clone \u0026ndash;recurse-submodules \u0026lt;main project repository\u0026gt; $ git submodule foreach git checkout \n 이미 로컬에 submodule이 존재하는 경우 갱신  이미 존재하는 submodule 갱신 (Main Project Root 폴더)  $ git submodule update --remote --merge   commit and push submodules  만일 새로운 branch로 작업하는 경우  새로운 Branch로 작업 (Main Project Root 폴더)  $ git submodule foreach git checkout -b \u0026lt;feature name\u0026gt;   \n 변경된 코드들 commit  변경된 코드들 Commit (Main Project Root 폴더)  $ git submodule foreach git add -A . $ git submodule foreach git commit -am \u0026#34;commit message\u0026#34; $ git submodule foreach git checkout \u0026lt;branch name\u0026gt; $ git submodule foreach git merge \u0026lt;feature name\u0026gt;   \n push submodules  Submodule Push (Main Project Root 폴더)  $ git submodule foreach git push   \n commit and push main project  Main Project Push (Main Project Root 폴더)  $ git commit -am \u0026#34;commit message\u0026#34; $ git push \u0026ndash;recurse-submodules=check   \n  위에서 언급한 것과 같이 push를 할 때는 반드시 submodule들을 먼저 처리하고 main project를 처리  해야 한다. 따라서 submodule들이 모두 push되었는지를 확인해야 한다.\n Main Project Push 전에 모든 Submodule들이 Push된 상태인지 확인 (Main Project Root 폴더)  $ git push --recurse-submodules=check # submodule들이 모두 push된 상태인지를 검사하고 확인되면 push 처리 $ git push --recurse-submodules=on-demand # submodule들을 모두 push하고 성공하면 push 처리   매번 명령어를 지정해서 처리하는 것을 항상 처리할 수 될 수 있도록 하기 위해서는 아래와 같이 설정으로 처리해 두면 된다.\n 항상 처리될 수 있도록 설정 (Main Project Root 폴더)  $ git config push.recurseSubmodules check $ git config push.recurseSubmodules on-demand   submodule 제거  .gitmodules 파일에서 대상 submodule 정보를 삭제한다. 변경된 내용을 stage 처리 한다.  변경사항 Stage 처리 (Main Project Root 폴더)  $ git add .gitmodules   \n .git/config 파일에서 대상 submodule 정보를 삭제한다.\n git 에서 cached 인덱스 정보를 제거한다.  Cached Index 삭제 (Main Project Root 폴더)  $ git rm \u0026ndash;cached \u0026lt;path to submodule\u0026gt; # 경로 맨 뒤의 \u0026#39;/\u0026#39;는 사용하지 않는다.   \n ./git/modules 폴더에서 대상 submodule 폴더 정보를 삭제한다.  git modules 에서 Submodule 경로 삭제 (Main Project Root 폴더)  $ rm .git/modules/\u0026lt;path to submodule\u0026gt; # 경로 맨 뒤의 \u0026#39;/\u0026#39;는 사용하지 않는다.   \n 변경된 내용을 commit 한다.\n 제거된 submodule 폴더를 삭제한다.  제거된 Submodule 폴더 삭제 (Main Project Root 폴더)  $ rm -rf \u0026lt;path to submodule\u0026gt;   \n  위의 내용은 기본적인 git 명령을 사용한 것이고 submodule 명령을 통하면 다음과 같이 더 간단하게 처리가 가능할 수 있다.\n git에서 submodule 관련 정보 삭제  Git의 Submodule 관련 정보 삭제 (Main Project Root 폴더)  $ git submodule deinit \u0026lt;path to submodule\u0026gt;   \n git에서 submodule 삭제  Git의 Submodule 삭제 (Main Project Root 폴더)  $ git rm \u0026lt;path to submodule\u0026gt;   \n 변경 내용 commit\n submodule 폴더 삭제  git modules 에서 Submodule 경로 삭제 (Main Project Root 폴더)  $ rm .git/modules/\u0026lt;path to submodule\u0026gt; # 경로 맨 뒤의 \u0026#39;/\u0026#39;는 사용하지 않는다.   \n  참고자료  git-scm Book Chapter 6. Git Tools - Submodule How to effectively delete a git submodule  "
},
{
	"uri": "http://ccambo.github.io/Git/Basics/",
	"title": "Basics",
	"tags": [],
	"description": "",
	"content": " Basics 이 문서에서는 Git 사용에 필요한 기본적인 정보들을 정리하고 있습니다.\n"
},
{
	"uri": "http://ccambo.github.io/FunnyLab/Blogging/",
	"title": "Blogging",
	"tags": [],
	"description": "",
	"content": " Blogging 이 문서에서는 Hugo 및 Hexo 블로그 구성에 필요한 정보들을 정리하고 있습니다.\n 댓글 시스템 utterances로 변경  기존 Disqus 댓글 시스템의 문제점으로 Github연동형 댓글 시스템인 utternaces로 변경한 내용을 정리합니다.\n OGP API 서버 Heroku에 배포하기  이 문서는 블로그에서 외부 게시글에 대한 미리보기를 작성하면서 Open Graph를 적용하는 방법을 정리한 것입니다. Hugo나 Hexo를 기준으로 적용하는데 필요한 OGP 처리용 API Server를 구성하는 내용이므로 OGP에 대한 상세한 내용은 아래의 참고 자료를 활용하시기 바랍니다. 기본적인 개발 환경은 이미 활용하는 것으로 가정하고 git / vscode / macbook을 기준으로 설명합니다 OGP란? 오픈그래프 (Open Graph)는 HTML 메타 태그의 종류 중의 하나로 사용성에 약간의 차이를 가진다. SNS에서 그 개념이 시작되었는데, SNS에 링크를 걸어 놓으면 이 링크가 어떤 데이터를 가지고 있는지를 알 수 있는 방법이 없기 때문에 링크에 대한 미리보기로써 이미지, 설명, 제목등을 나타내기 위한 태그들이다.\n "
},
{
	"uri": "http://ccambo.github.io/Cloud/Concepts/",
	"title": "Concepts",
	"tags": [],
	"description": "",
	"content": " Concepts Cloud와 연계되는 개념들을 정리합니다.\n"
},
{
	"uri": "http://ccambo.github.io/Git/",
	"title": "Git",
	"tags": [],
	"description": "",
	"content": " Git 관련 정보들 정리 이 문서에서는 Git 사용에 필요한 정보들을 정리하고 있습니다.\n"
},
{
	"uri": "http://ccambo.github.io/Dev/Vue/",
	"title": "Vue",
	"tags": [],
	"description": "",
	"content": " Vue Vue에 대한 소개 및 사용하는데 필요한 정보들을 정리합니다.\n Vue 키 포인트 소개  프로젝트에 Vue를 도입한 결정적인 이유\n Vue 기본 개념  Vue.js에 대한 간략한 기본 개념 소개\n "
},
{
	"uri": "http://ccambo.github.io/Dev/Web/",
	"title": "Web",
	"tags": [],
	"description": "",
	"content": " Web 이 문서에서는 웹 구성에 필요한 정보들을 정리하고 있습니다.\n NPM vs YARN  npm과 yarn에 대한 비교\n "
},
{
	"uri": "http://ccambo.github.io/FunnyLab/Blogging/how-to-deploy-api-server-to-heroku/",
	"title": "OGP API 서버 Heroku에 배포하기",
	"tags": ["API Server", "Heroku", "Open Graph", "OGP"],
	"description": "",
	"content": " 이 문서는 블로그에서 외부 게시글에 대한 미리보기를 작성하면서 Open Graph를 적용하는 방법을 정리한 것입니다. Hugo나 Hexo를 기준으로 적용하는데 필요한 OGP 처리용 API Server를 구성하는 내용이므로 OGP에 대한 상세한 내용은 아래의 참고 자료를 활용하시기 바랍니다. 기본적인 개발 환경은 이미 활용하는 것으로 가정하고 git / vscode / macbook을 기준으로 설명합니다\n OGP란? 오픈그래프 (Open Graph)는 HTML 메타 태그의 종류 중의 하나로 사용성에 약간의 차이를 가진다. SNS에서 그 개념이 시작되었는데, SNS에 링크를 걸어 놓으면 이 링크가 어떤 데이터를 가지고 있는지를 알 수 있는 방법이 없기 때문에 링크에 대한 미리보기로써 이미지, 설명, 제목등을 나타내기 위한 태그들이다.\n오픈그래프에 대해서는 The Open Graph Protocol 사이트를 참고하면 된다.\n오픈 그래프의 기본적인 태그들을 다음과 같다.\n기본 태그들   Tag Description     og:title 사이트의 제목 태그   og:type 사이트의 종류 스타일 태그 (ex. website, video, movie, \u0026hellip;)   og:image 사이트의 대표 이미지 태그   og:url 사이트의 대표 URL 태그    옵션으로 적용할 수 있는 태그들을 다음과 같다.\n옵션 태그들   Tag Description     og:audio 사이트의 포함되는 Audio 파일 태그   og:description 사이트의 설명 태그   og:determiner 사이트의 구분자 태그   og:locale 사이트의 언어 태그 (기본 값은 en_US, 한글은 ko_KR, \u0026hellip;)   og:locale:alternate 사이트의 다국어일 경우 대체 언어 태그   og:site_name 사이트의 세부 카테고리 의미 태그   og:video 사이트의 포함되는 Video 파일 태그    추가적으로 객체들 (Image, Audio, Video, \u0026hellip;)에 대한 구조 속성 태그들은 다음과 같다.\n객체 구조 태그들   Tag Description     og:object 또는 og:object:url 객체의 경로 (eg. Image, Audio, Video, \u0026hellip;) 태그   og:object:secure_url SSL/TLS(HTTPS) 경로 태그   og:object:type 객체 유형 태그 (eg. image/jpeg, application/x-shockwave-flash, audio/mpeg, \u0026hellip;)   og:object:width 객체 너비 태그   og:object:height 객체 높이 태그   og:object:alt 객체 설명 태그    OGP를 위한 API 구성하기 API 구성의 목적은 링크 URL이 지정되면 해당 URL의 HTML 내용 중에서 Head 태그 내의 Open Graph 정보를 추출해서 JSON 형식으로 반환하는 것이다. 이 정보를 기준으로 각 블로그 툴 (SSG : Static Site Generator)에서는 SNS처럼 게시글 링크를 표시하는 Preview Box를 구성하게 된다.\n가장 먼저할 것은 API를 구동해서 사용할 수 있는 무료로 지원되는 호스팅 서버를 결정하는 것이다. 처음에는 firebase를 검토해서 구현을 했지만 외부 URL을 긁어와야 하는 부분에서 Firebase는 외부로 연계되는 경우 무료 계정에서는 사용할 수 없는 제한이 존재하기 때문에 Heroku 를 이용하는 것으로 결정했다.\nAWS, Azure, GCP 등의 외부에서 호출해서 결과를 받을 수 있는 호스팅을 이미 할 수 있는 계정이 존재한다면 그것을 이용해도 된다.\n 가장 먼저 시작해야 할 것이 Heroku의 계정을 만드는 것이다.\nHeroku 계정설정 Heroku는 Git 기반으로 운영되기 때문에 당연히 로컬 PC에 git가 설치되어 있어야 한다.\n Heroku 사이트에 계정 생성 무료 계정은 아래와 같은 제한이 있다\n 30분간 접속이 없으면 사이트를 Sleep 시킨다. (요청이 들어와서 재 구동되는데 10~30초 정도 걸림) 계정 당 한달에 550시간만 사용 가능하다. 계정에 사이트가 여러 개인 경우는 합산 시간을 기준으로 한다.  [ 회원가입 ]  아래와 같이 정보를 등록하고 \u0026ldquo;Create Free Account\u0026rdquo; 버튼을 눌러서 가입하면 된다. 기본적으로 사용하는 언어는 본인이 주로 사용하는 언어를 선택하면 된다.\n[ 회원정보설정 ]  Heroku CLI 설치 Heroku는 Git기반이기 때문에 로컬 PC에서 작업하고 Heroku로 Push해서 처리하면 된다. 따라서 Heroku 연동을 위한 CLI (Command Line Interface)를 설치해야 한다.\n heroku 사이트에 로그인한 후에 다운로드로 이동해서 플랫폼에 맞는 것을 다운로드해서 설치 (아래 그림의 빨간색 처리 부분을 통해서 이동) [ CLI 설치 페이지 ] \n 설치 페이지의 내용대로 설치\n  Heroku CLI 주요 명령 정리\nHeroku CLI Commands   Command Description     heroku login 로그인   heroku logout 로그인은 재부팅을 하더라도 지속성을 가지므로 로그아웃을 원할 경우는 이 명령을 수행해야 한다.   heroku create [프로젝트 이름] Git 저장소와 연결될 폴더에서 새로운 프로젝트를 생성하는 명령으로 \u0026ldquo;프로젝트 이름\u0026rdquo;을 주지 않으면 랜덤으로 생성되고 URL과 연계되므로 프로젝트 이름을 지정하는 것이 좋다.   heroku remote -v 생성된 프로젝트의 원격 저장소 정보를 보는 것으로 로컬 저장소는 \u0026ldquo;heroku\u0026rdquo; 라는 이름으로 생성된다.   heroku git:remote -a 프로젝트 이름 위의 create가 새로운 프로젝트를 생성하는 것이라면 이미 존재하는 프로젝트에 연결하는 것은 이 명령으로 프로젝트를 지정하면 된다.   heroku config:set [키=값] 프로젝트와 연계되는 저장소에 환경 변수를 설정한다.   heroku config 프로젝트와 연계되는 저장소에 설정되어 있는 환경 변수들을 출력한다.   heroku config:get [키] 프로젝트와 연계되는 저장소에 설정되어 있는 환경 변수들 중에서 지정한 키의 값을 출력한다.   heroku config:unset [키] 프로젝트와 연계되는 저장소에 설정되어 있는 환경 변수들 중에서 지정한 키의 환경 변수를 삭제한다.   heroku logs [\u0026ndash;tail] Heroku에서 구동된 서버의 Console log를 출력한다. 테스트 중에 오류나 디버그 용도로 사용한다.    Heroku의 프로젝트 이름은 저장소 명칭일뿐만 아니라 향후 외부로 노출될 App 식별명이기도 하므로 반드시 잘 생각해보고 생성해야 한다. 외부에서 접속하는 주소는 [프로젝트 명].herokuapp.com 으로 생성된다.\n OGP 처리를 위한 API 구성 (로컬 PC) 아주 간단한 OGP API Server를 구성할 것이기 때문에 node + express + ogp_parser 조합  으로 아래와 같이 소스를 구성한다.\n 기본 설치 작업  $ npm init # package.json 구성 $ npm install express --save # node express 설치 $ npm install ogp-parser --save # ogp-parser 설치   위와 같이 기본적인 설치를 한 후에 package.json 파일을 열고 나머지 부분을 구성하도록 한다.\n 전체 package.json 파일  1{ 2 \u0026#34;name\u0026#34;: \u0026#34;ogp-to-json\u0026#34;, 3 \u0026#34;version\u0026#34;: \u0026#34;0.0.1\u0026#34;, 4 \u0026#34;description\u0026#34;: \u0026#34;지정한 URL 정보를 기준으로 Open Graph 정보를 추출해서 JSON 형식으로 반환합니다.\u0026#34;, 5 \u0026#34;main\u0026#34;: \u0026#34;index.js\u0026#34;, 6 \u0026#34;scripts\u0026#34;: { 7 \u0026#34;start\u0026#34;: \u0026#34;node ./\u0026#34; 8 }, 9 \u0026#34;keywords\u0026#34;: [ 10 \u0026#34;Open Graph\u0026#34;, 11 \u0026#34;ogp\u0026#34;, 12 \u0026#34;Heroku\u0026#34; 13 ], 14 \u0026#34;author\u0026#34;: \u0026#34;morris chang\u0026#34;, 15 \u0026#34;license\u0026#34;: \u0026#34;MIT\u0026#34;, 16 \u0026#34;engines\u0026#34;: { 17 \u0026#34;node\u0026#34;: \u0026#34;v13.2.0\u0026#34;, 18 \u0026#34;npm\u0026#34;: \u0026#34;6.13.2\u0026#34; 19 }, 20 \u0026#34;dependencies\u0026#34;: { 21 \u0026#34;express\u0026#34;: \u0026#34;^4.17.1\u0026#34;, 22 \u0026#34;ogp-parser\u0026#34;: \u0026#34;^0.4.4\u0026#34; 23 } 24}   위의 package.json 파일의 내용 중에 아래 서술한 부분은 로컬테스트와 Heroku에서 실행될 정보를 구성한 것이다.\n scripts : 로컬 및 Heroku에서 npm을 통해서 실행할 명령이다. (eg. npm start) main : scripts/start에 \u0026ldquo;node ./\u0026rdquo; 으로 지정하면 main에 설정된 파일을 처리한다. main 지정이 없을 경우는 scripts/start를 \u0026ldquo;node ./index.js\u0026rdquo;로 해 줘야 한다. engines : Heroku에서 실행될 node와 npm에 대한 버전 정보를 지정한 것이다. (별다른 문제가 없다면 로컬에 설치된 버전을 그대로 이용하면 된다.)  버전 정보를 모를 경우는 node -v, npm -v 명령으로 현재 설치된 버전 확인이 가능하다.   index.js 파일에 아래와 같이 코드를 구성한다.\n index.js  1const express = require(\u0026#39;express\u0026#39;); 2 3const app = express(); 4const PORT = process.env.PORT || 80 5 6// 호출 url : opg-to-json.herokuapp.com/ogp?url=..... 7app.get(\u0026#34;/ogp\u0026#34;, (req, res) =\u0026gt; { 8 const parser = require(\u0026#39;ogp-parser\u0026#39;); 9 const params = req.query; 10 const cacheControl = \u0026#39;public, max-age=31557600, s-maxage=31557600\u0026#39;; // cache 1year 11 12 if (!params.hasOwnProperty(\u0026#39;url\u0026#39;)) { 13 console.error(\u0026#39;Error getting ogp data: Please provide url parameter\u0026#39;); 14 return res.json({error: \u0026#39;Error getting ogp data: Please provide url parameter\u0026#39;}); 15 } 16 17 return parser(encodeURI(params[\u0026#39;url\u0026#39;]), false) 18 .then((data) =\u0026gt; { 19 console.log(data); 20 console.log(params[\u0026#39;url\u0026#39;]); 21 if (!data.hasOwnProperty(\u0026#39;title\u0026#39;)) { 22 console.error(\u0026#39;Error getting ogp data: no ogpData returned\u0026#39;); 23 return res.json({error: \u0026#39;No OGP data returned from given url\u0026#39;}); 24 } 25 let ogpData = {}; 26 ogpData[\u0026#39;siteName\u0026#39;] = data.title; 27 for(let prop in data.ogp) { 28 if (/^og:/g.test(prop)) { 29 ogpData[prop.split(\u0026#39;:\u0026#39;)[1]] = data.ogp[prop][0]; 30 } 31 } 32 return res.set(\u0026#39;Cache-Control\u0026#39;, cacheControl).json(ogpData); 33 }) 34 .catch((err) =\u0026gt; { 35 console.error(\u0026#39;Error getting ogp data: \u0026#39; + err); 36 return res.json({error: err}); 37 }); 38}); 39 40app.listen(PORT, err =\u0026gt; { 41 if (err) throw err; 42 console.log(\u0026#34;%c Server running\u0026#34;, \u0026#34;color:green\u0026#34;); 43});   위의 코드는 아래와 같이 처리를 위한 정보를 구성하고 있다.\n line 3 : express 서버 인스턴스 생성 line 4 : express가 리스닝할 포트를 지정한다. heroku에서는 환경변수에서 PORT를 할당받는 방식을 선택해야 한다. line 7 : \u0026ldquo;ogp\u0026rdquo; 패스로 Request가 오면 처리를 수행하는 핸들러를 구성한다. line 9 : Request로 전달된 Parameter들을 변수에 할당한다. line 12 : Request의 Query String으로 \u0026ldquo;url\u0026rdquo;이 전달되었는지를 검사한다. line 13-14 : \u0026ldquo;url\u0026rdquo; 이 없다면 오류 처리 line 17 : \u0026ldquo;ogp-parser\u0026rdquo;를 이용해서 지정된 \u0026ldquo;Url\u0026rdquo;의 데이터를 읽어서 OGP 데이터 추출 line 18-33 : OGP 데이터의 존재 여부 검증 및 캐시 데이터 및 반환 데이터 처리와 오류 발생시 처리 line 40-43 : express가 지정한 포트의 요청을 받을 수 있도록 구동  이제 로컬에서 먼저 실행을 해서 정상적인 OGP json이 반환되고 있는지를 확인해 보면 된다.\n shell에서 실행 검증  $ npm start $ curl \u0026#34;http://localhost/ogp?url=http://ccambo.gitlab.io/2017/07/09/VSCODE-VSCode%EC%97%90-Git-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/\u0026#34;   정상적으로 JSON 포맷의 OGP 데이터가 출력되는 것을 확인했으면 이제 Heroku에 배포를 하면 된다.\nHeroku에 배포하기 Heroku가 git 기반으로 동작한다고 이야기를 했으므로 git 저장소 생성(프로젝트 생성)을 진행한다.\n shell에서 git구성 및 Heroku 프로젝트 생성 (로컬 프로젝트 폴더)  $ git init # 프로젝트 폴더에 git 저장소 구성 $ heroku login # heroku에 로그인 id/pw를 입력해서 처리 (이미 되어있는 경우는 Skip) $ heroku create [프로젝트 이름] # heroku에 프로젝트(저장소) 생성 Creating ⬢ [프로젝트 이름]... done https://[프로젝트 이름].herokuapp.com/ | https://git.heroku.com/[프로젝트 이름].git # heroku 서버 접속 URL 및 Git 저장소 URL 표시   생성이 끝나면 Heroku 프로젝트 접속용 URL과 Git 저장소 URL이 출력된다. 이를 이용해서 로컬 저장소를 Heroku 저장소와 연결한다.\n shell에서 원격 저장소 연결 (로컬 프로젝트 폴더)  $ git remote add heroku [프로젝트 Git 저장소 URL] # 위에서 출력된 GIt 저장소 URL 사용   만일 해당 출력을 확인하지 못해서 git 저장소 URL을 모를 경우는 Heroku에 접속해서 Dashboard로 이동한 후에 생성한 프로젝트의 \u0026ldquo;Settings\u0026rdquo; 정보를 통해서 확인할 수 있다.\n[ Heroku Dashboard 페이지에서 프로젝트 선택 ]  이제 저장소 연결이 완성되었으므로 로컬의 소스를 Heroku에 올리면 된다. (일반적인 git 처리와 동일하다)\n shell에서 Heroku로 소스 올리기  $ git add . # 변경된 파일들 stage 처리 $ git commit -m \u0026#34;커밋 메시지\u0026#34; # stage를 로컬 저장소에 commit $ git push heroku master # 로컬 저장소(heroku)의 commit 내용을 Heroku (master)로 push (upload) $ heroku open # 저장소에 올려진 소스를 기반으로 Heroku Application 구동   별다른 오류가 없었다면 heroku open  로 실행된 브라우저는 당연히 Cannot GET / 라는 오류가 발생하는 것이 정상이다.\n위에서 구동한 소스가 /ogp 패스에 대해서만 동작하도록 구성했기 때문으로 정상적으로 구동된 것을 확인할 수 있다.\n정상적인 결과를 확인하기 위해서는 열려있는 브라우저 주소 창에 다음과 같이 입력하면 된다.\n 브라우저 주소창에 URL 설정  \u0026#34;http://[프로젝트 이름].herokuapp.com/ogp?url=http://ccambo.gitlab.io/2017/07/09/VSCODE-VSCode%EC%97%90-Git-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/\u0026#34;   또는 터미널에서 아래와 같이 curl을 이용해서도 확인 가능하다.\n shell에서 URL 설정  $ curl \u0026#34;http://[프로젝트 이름].herokuapp.com/ogp?url=http://ccambo.gitlab.io/2017/07/09/VSCODE-VSCode%EC%97%90-Git-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/\u0026#34;   결론 위와 같이 처음으로 단순한 API Server를 로컬에서 구성해서 Git 기반의 무료 어플리케이션 호스팅인 Heroku에 올려서 처리하는 것을 확인해 보았다.\n 무료 계정을 일부 제한이 존재한다. Git 기반으로 통합되어 있다. Heroku CLI를 기준으로 Heroku에 각종 처리를 수행한다.  참고자료  Open Graph How to Use Open Graph Tags Heroku(무료 호스팅 서버) 설치 및 사용기 express/node.js 를 이용해 서버를 만들어 heroku에 올리는 방법  "
},
{
	"uri": "http://ccambo.github.io/Cloud/",
	"title": "Cloud",
	"tags": [],
	"description": "",
	"content": " Cloud 이 문서에서는 Cloud에 필요한 정보들을 정리하고 있습니다.\n"
},
{
	"uri": "http://ccambo.github.io/Git/Submdule/",
	"title": "Submodule",
	"tags": [],
	"description": "",
	"content": " Submodule 이 문서에서는 Git의 Submodule에 관련된 정보들을 정리하고 있습니다.\n"
},
{
	"uri": "http://ccambo.github.io/Dev/",
	"title": "Dev",
	"tags": [],
	"description": "",
	"content": " Developments 이 문서에서는 개발에 필요한 정보들을 정리하고 있습니다.\n"
},
{
	"uri": "http://ccambo.github.io/FunnyLab/",
	"title": "FunnyLab",
	"tags": [],
	"description": "",
	"content": " Funny Lab 엉뚱하고 재미있는 상상들을 정리하고 있습니다.\n"
},
{
	"uri": "http://ccambo.github.io/Cloud/Docker/",
	"title": "Docker",
	"tags": [],
	"description": "이 페이지는 Docker에 대한 관련된 정보들을 정리합니다.",
	"content": " Docker 관련 정보들 정리!!! "
},
{
	"uri": "http://ccambo.github.io/Cloud/Kubernetes/",
	"title": "Kubernetes",
	"tags": [],
	"description": "이 페이지는 Kubernetes에 관련된 정보를 정리합니다.",
	"content": " Kubernetes 관련 정보 정리!!! "
},
{
	"uri": "http://ccambo.github.io/Cloud/Docker/Tips/",
	"title": "Tips",
	"tags": [],
	"description": "Docker 사용 중에 발생한 오류들의 해결방법이나 유용한 정보들을 정리합니다.",
	"content": " Errors and Tips "
},
{
	"uri": "http://ccambo.github.io/Git/Tips/",
	"title": "Tips",
	"tags": [],
	"description": "",
	"content": " Tips 이 문서에서는 Git 사용 중에 발생한 오류들의 해결 방법이나 유용한 정보들을 정리하고 있습니다.\n"
},
{
	"uri": "http://ccambo.github.io/",
	"title": "MSFL",
	"tags": [],
	"description": "",
	"content": " 지식 저장소 여러 가지 정보들을 하나의 지식 저장소처럼 꾸미는 꿈을 가지고 진행하고 있습니다.\n"
}]